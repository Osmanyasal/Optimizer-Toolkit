#include <cstdint>

namespace optkit::intel{
	enum class spr : uint64_t {
		UNHALTED_CORE_CYCLES = 0x3c, // Count core clock cycles whenever the clock signal on the specific core is running (not halted)
		UNHALTED_REFERENCE_CYCLES = 0x0300, // Unhalted reference cycles
		INSTRUCTION_RETIRED = 0xc0, // Number of instructions at retirement
		INSTRUCTIONS_RETIRED = 0xc0, // Number of instructions at retirement
		AMX_OPS_RETIRED = 0x00ce, // Advance Matrix Extension (AMX) operations retired
		AMX_OPS_RETIRED_MASK_BF16 = 0x0200ull, // AMX retired arithmetic BF16 operations.
		AMX_OPS_RETIRED_MASK_INT8 = 0x0100ull, // AMX retired arithmetic integer 8-bit operations.
		INT_VEC_RETIRED = 0x00e7, // integer ADD
		INT_VEC_RETIRED_MASK_128BIT = 0x1300ull, // TBD
		INT_VEC_RETIRED_MASK_256BIT = 0xac00ull, // TBD
		INT_VEC_RETIRED_MASK_ADD_128 = 0x0300ull, // integer ADD
		INT_VEC_RETIRED_MASK_ADD_256 = 0x0c00ull, // integer ADD
		INT_VEC_RETIRED_MASK_MUL_256 = 0x8000ull, // TBD
		INT_VEC_RETIRED_MASK_SHUFFLES = 0x4000ull, // TBD
		INT_VEC_RETIRED_MASK_VNNI_128 = 0x1000ull, // TBD
		INT_VEC_RETIRED_MASK_VNNI_256 = 0x2000ull, // TBD
		MEM_UOP_RETIRED = 0x00e5, // Retired memory uops for any access
		MEM_UOP_RETIRED_MASK_ANY = 0x0300ull, // Retired memory uops for any access
		MISC2_RETIRED = 0x00e0, // TBD
		MISC2_RETIRED_MASK_LFENCE = 0x2000ull, // TBD
		MEM_LOAD_MISC_RETIRED = 0x00d4, // Retired instructions with at least 1 uncacheable load or lock.
		MEM_LOAD_MISC_RETIRED_MASK_UC = 0x0400ull, // Retired instructions with at least 1 uncacheable load or lock.
		MEM_LOAD_L3_MISS_RETIRED = 0x00d3, // Retired load instructions which data sources missed L3 but serviced from local dram
		MEM_LOAD_L3_MISS_RETIRED_MASK_LOCAL_DRAM = 0x0100ull, // Retired load instructions which data sources missed L3 but serviced from local dram
		MEM_LOAD_L3_MISS_RETIRED_MASK_REMOTE_DRAM = 0x0200ull, // TBD
		MEM_LOAD_L3_MISS_RETIRED_MASK_REMOTE_FWD = 0x0800ull, // Retired load instructions whose data sources was forwarded from a remote cache
		MEM_LOAD_L3_MISS_RETIRED_MASK_REMOTE_HITM = 0x0400ull, // TBD
		MEM_LOAD_L3_MISS_RETIRED_MASK_REMOTE_PMM = 0x1000ull, // Retired load instructions with remote Intel Optane DC persistent memory as the data source where the data request missed all caches.
		MEM_LOAD_L3_HIT_RETIRED = 0x00d2, // Retired load instructions whose data sources were L3 hit and cross-core snoop missed in on-pkg core cache.
		MEM_LOAD_L3_HIT_RETIRED_MASK_XSNP_FWD = 0x0400ull, // Retired load instructions whose data sources were HitM responses from shared L3
		MEM_LOAD_L3_HIT_RETIRED_MASK_XSNP_MISS = 0x0100ull, // Retired load instructions whose data sources were L3 hit and cross-core snoop missed in on-pkg core cache.
		MEM_LOAD_L3_HIT_RETIRED_MASK_XSNP_NONE = 0x0800ull, // Retired load instructions whose data sources were hits in L3 without snoops required
		MEM_LOAD_L3_HIT_RETIRED_MASK_XSNP_NO_FWD = 0x0200ull, // Retired load instructions whose data sources were L3 and cross-core snoop hits in on-pkg core cache
		MEM_LOAD_RETIRED = 0x00d1, // Retired load instructions with L1 cache hits as data sources
		MEM_LOAD_RETIRED_MASK_FB_HIT = 0x4000ull, // Number of completed demand load requests that missed the L1
		MEM_LOAD_RETIRED_MASK_L1_HIT = 0x0100ull, // Retired load instructions with L1 cache hits as data sources
		MEM_LOAD_RETIRED_MASK_L1_MISS = 0x0800ull, // Retired load instructions missed L1 cache as data sources
		MEM_LOAD_RETIRED_MASK_L2_HIT = 0x0200ull, // Retired load instructions with L2 cache hits as data sources
		MEM_LOAD_RETIRED_MASK_L2_MISS = 0x1000ull, // Retired load instructions missed L2 cache as data sources
		MEM_LOAD_RETIRED_MASK_L3_HIT = 0x0400ull, // Retired load instructions with L3 cache hits as data sources
		MEM_LOAD_RETIRED_MASK_L3_MISS = 0x2000ull, // Retired load instructions missed L3 cache as data sources
		MEM_LOAD_RETIRED_MASK_LOCAL_PMM = 0x8000ull, // Retired load instructions with local Intel Optane DC persistent memory as the data source where the data request missed all caches.
		MEM_INST_RETIRED = 0x00d0, // Retired load instructions that miss the STLB.
		MEM_INST_RETIRED_MASK_ALL_LOADS = 0x8100ull, // All retired load instructions.
		MEM_INST_RETIRED_MASK_ALL_STORES = 0x8200ull, // All retired store instructions.
		MEM_INST_RETIRED_MASK_ANY = 0x8300ull, // All retired memory instructions.
		MEM_INST_RETIRED_MASK_LOCK_LOADS = 0x2100ull, // Retired load instructions with locked access.
		MEM_INST_RETIRED_MASK_SPLIT_LOADS = 0x4100ull, // Retired load instructions that split across a cacheline boundary.
		MEM_INST_RETIRED_MASK_SPLIT_STORES = 0x4200ull, // Retired store instructions that split across a cacheline boundary.
		MEM_INST_RETIRED_MASK_STLB_MISS_LOADS = 0x1100ull, // Retired load instructions that miss the STLB.
		MEM_INST_RETIRED_MASK_STLB_MISS_STORES = 0x1200ull, // Retired store instructions that miss the STLB.
		FP_ARITH_INST_RETIRED2 = 0x00cf, // TBD
		FP_ARITH_INST_RETIRED2_MASK_128B_PACKED_HALF = 0x0400ull, // TBD
		FP_ARITH_INST_RETIRED2_MASK_256B_PACKED_HALF = 0x0800ull, // TBD
		FP_ARITH_INST_RETIRED2_MASK_512B_PACKED_HALF = 0x1000ull, // TBD
		FP_ARITH_INST_RETIRED2_MASK_COMPLEX_SCALAR_HALF = 0x0200ull, // TBD
		FP_ARITH_INST_RETIRED2_MASK_SCALAR = 0x0300ull, // Number of all Scalar Half-Precision FP arithmetic instructions(1) retired - regular and complex.
		FP_ARITH_INST_RETIRED2_MASK_SCALAR_HALF = 0x0100ull, // TBD
		FP_ARITH_INST_RETIRED2_MASK_VECTOR = 0x1c00ull, // Number of all Vector (also called packed) Half-Precision FP arithmetic instructions(1) retired.
		MEM_TRANS_RETIRED = 0x01cd, // Counts randomly selected loads when the latency from first dispatch to completion is greater than 128 cycles.
		MEM_TRANS_RETIRED_MASK_LOAD_LATENCY = 0x100, // Memory load instructions retired above programmed clocks
		MEM_TRANS_RETIRED_MASK_STORE_SAMPLE = 0x0200ull, // Retired instructions with at least 1 store uop. This PEBS event is the trigger for stores sampled by the PEBS Store Facility.
		MISC_RETIRED = 0x00cc, // Increments whenever there is an update to the LBR array.
		MISC_RETIRED_MASK_LBR_INSERTS = 0x2000ull, // Increments whenever there is an update to the LBR array.
		RTM_RETIRED = 0x00c9, // Number of times an RTM execution started.
		RTM_RETIRED_MASK_ABORTED = 0x0400ull, // Number of times an RTM execution aborted.
		RTM_RETIRED_MASK_ABORTED_EVENTS = 0x8000ull, // Number of times an RTM execution aborted due to none of the previous 4 categories (e.g. interrupt)
		RTM_RETIRED_MASK_ABORTED_MEM = 0x0800ull, // Number of times an RTM execution aborted due to various memory events (e.g. read/write capacity and conflicts)
		RTM_RETIRED_MASK_ABORTED_MEMTYPE = 0x4000ull, // Number of times an RTM execution aborted due to incompatible memory type
		RTM_RETIRED_MASK_ABORTED_UNFRIENDLY = 0x2000ull, // Number of times an RTM execution aborted due to HLE-unfriendly instructions
		RTM_RETIRED_MASK_COMMIT = 0x0200ull, // Number of times an RTM execution successfully committed
		RTM_RETIRED_MASK_START = 0x0100ull, // Number of times an RTM execution started.
		SQ_MISC = 0x002c, // Counts bus locks
		SQ_MISC_MASK_BUS_LOCK = 0x1000ull, // Counts bus locks
		FP_ARITH_INST_RETIRED = 0x00c7, // Counts number of SSE/AVX computational scalar double precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 1 computational operation. Applies to SSE* and AVX* scalar double precision floating-point instructions: ADD SUB MUL DIV MIN MAX SQRT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions count twice as they perform 2 calculations per element.
		FP_ARITH_INST_RETIRED_MASK_128B_PACKED_DOUBLE = 0x0400ull, // Counts number of SSE/AVX computational 128-bit packed double precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 2 computation operations
		FP_ARITH_INST_RETIRED_MASK_128B_PACKED_SINGLE = 0x0800ull, // Number of SSE/AVX computational 128-bit packed single precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 4 computation operations
		FP_ARITH_INST_RETIRED_MASK_256B_PACKED_DOUBLE = 0x1000ull, // Counts number of SSE/AVX computational 256-bit packed double precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 4 computation operations
		FP_ARITH_INST_RETIRED_MASK_256B_PACKED_SINGLE = 0x2000ull, // Counts number of SSE/AVX computational 256-bit packed single precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 8 computation operations
		FP_ARITH_INST_RETIRED_MASK_4_FLOPS = 0x1800ull, // Number of SSE/AVX computational 128-bit packed single and 256-bit packed double precision FP instructions retired; some instructions will count twice as noted below.  Each count represents 2 or/and 4 computation operations
		FP_ARITH_INST_RETIRED_MASK_512B_PACKED_DOUBLE = 0x4000ull, // Counts number of SSE/AVX computational 512-bit packed double precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 8 computation operations
		FP_ARITH_INST_RETIRED_MASK_512B_PACKED_SINGLE = 0x8000ull, // Counts number of SSE/AVX computational 512-bit packed single precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 16 computation operations
		FP_ARITH_INST_RETIRED_MASK_8_FLOPS = 0x6000ull, // Number of SSE/AVX computational 256-bit packed single precision and 512-bit packed double precision  FP instructions retired; some instructions will count twice as noted below.  Each count represents 8 computation operations
		FP_ARITH_INST_RETIRED_MASK_SCALAR = 0x0300ull, // Number of SSE/AVX computational scalar floating-point instructions retired; some instructions will count twice as noted below.  Applies to SSE* and AVX* scalar
		FP_ARITH_INST_RETIRED_MASK_SCALAR_DOUBLE = 0x0100ull, // Counts number of SSE/AVX computational scalar double precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 1 computational operation. Applies to SSE* and AVX* scalar double precision floating-point instructions: ADD SUB MUL DIV MIN MAX SQRT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions count twice as they perform 2 calculations per element.
		FP_ARITH_INST_RETIRED_MASK_SCALAR_SINGLE = 0x0200ull, // Counts number of SSE/AVX computational scalar single precision floating-point instructions retired; some instructions will count twice as noted below.  Each count represents 1 computational operation. Applies to SSE* and AVX* scalar single precision floating-point instructions: ADD SUB MUL DIV MIN MAX SQRT RSQRT RCP FM(N)ADD/SUB.  FM(N)ADD/SUB instructions count twice as they perform 2 calculations per element.
		FP_ARITH_INST_RETIRED_MASK_VECTOR = 0xfc00ull, // Number of any Vector retired FP arithmetic instructions
		FRONTEND_RETIRED = 0x01c6, // Retired Instructions who experienced a critical DSB miss.
		FRONTEND_RETIRED_MASK_ANY_DSB_MISS = 0x0100ull, // Retired Instructions who experienced DSB miss.
		FRONTEND_RETIRED_MASK_DSB_MISS = 0x1100ull, // Retired Instructions who experienced a critical DSB miss.
		FRONTEND_RETIRED_MASK_ITLB_MISS = 0x1400ull, // Retired Instructions who experienced iTLB true miss.
		FRONTEND_RETIRED_MASK_L1I_MISS = 0x1200ull, // Retired Instructions who experienced Instruction L1 Cache true miss.
		FRONTEND_RETIRED_MASK_L2_MISS = 0x1300ull, // Retired Instructions who experienced Instruction L2 Cache true miss.
		FRONTEND_RETIRED_MASK_LATENCY_GE_1 = 0x60010600ull, // Retired instructions after front-end starvation of at least 1 cycle
		FRONTEND_RETIRED_MASK_LATENCY_GE_128 = 0x60800600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 128 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_16 = 0x60100600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 16 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_2 = 0x60020600ull, // Retired instructions after front-end starvation of at least 2 cycles
		FRONTEND_RETIRED_MASK_LATENCY_GE_256 = 0x61000600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 256 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_2_BUBBLES_GE_1 = 0x10020600ull, // Retired instructions that are fetched after an interval where the front-end had at least 1 bubble-slot for a period of 2 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_32 = 0x60200600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 32 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_4 = 0x60040600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 4 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_512 = 0x62000600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 512 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_64 = 0x60400600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 64 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_LATENCY_GE_8 = 0x60080600ull, // Retired instructions that are fetched after an interval where the front-end delivered no uops for a period of 8 cycles which was not interrupted by a back-end stall.
		FRONTEND_RETIRED_MASK_MS_FLOWS = 0x0800ull, // TBD
		FRONTEND_RETIRED_MASK_STLB_MISS = 0x1500ull, // Retired Instructions who experienced STLB (2nd level TLB) true miss.
		FRONTEND_RETIRED_MASK_UNKNOWN_BRANCH = 0x1700ull, // TBD
		BR_MISP_RETIRED = 0x00c5, // Mispredicted branch instructions retired.
		BR_MISP_RETIRED_MASK_ALL_BRANCHES = 0x0000ull, // All mispredicted branch instructions retired.
		BR_MISP_RETIRED_MASK_COND = 0x1100ull, // Mispredicted conditional branch instructions retired.
		BR_MISP_RETIRED_MASK_COND_NTAKEN = 0x1000ull, // Mispredicted non-taken conditional branch instructions retired.
		BR_MISP_RETIRED_MASK_COND_TAKEN = 0x0100ull, // Number of branch instructions retired that were mispredicted and taken.
		BR_MISP_RETIRED_MASK_INDIRECT = 0x8000ull, // Miss-predicted near indirect branch instructions retired (excluding returns)
		BR_MISP_RETIRED_MASK_INDIRECT_CALL = 0x0200ull, // Mispredicted indirect CALL retired.
		BR_MISP_RETIRED_MASK_NEAR_TAKEN = 0x2000ull, // Number of near branch instructions retired that were mispredicted and taken.
		BR_MISP_RETIRED_MASK_RET = 0x0800ull, // This event counts the number of mispredicted ret instructions retired. Non PEBS
		BR_INST_RETIRED = 0x00c4, // Branch instructions retired.
		BR_INST_RETIRED_MASK_ALL_BRANCHES = 0x0000ull, // All branch instructions retired.
		BR_INST_RETIRED_MASK_COND = 0x1100ull, // Conditional branch instructions retired.
		BR_INST_RETIRED_MASK_COND_NTAKEN = 0x1000ull, // Not taken branch instructions retired.
		BR_INST_RETIRED_MASK_COND_TAKEN = 0x0100ull, // Taken conditional branch instructions retired.
		BR_INST_RETIRED_MASK_FAR_BRANCH = 0x4000ull, // Far branch instructions retired.
		BR_INST_RETIRED_MASK_INDIRECT = 0x8000ull, // Indirect near branch instructions retired (excluding returns)
		BR_INST_RETIRED_MASK_NEAR_CALL = 0x0200ull, // Direct and indirect near call instructions retired.
		BR_INST_RETIRED_MASK_NEAR_RETURN = 0x0800ull, // Return instructions retired.
		BR_INST_RETIRED_MASK_NEAR_TAKEN = 0x2000ull, // Taken branch instructions retired.
		MACHINE_CLEARS = 0x00c3, // Number of machine clears (nukes) of any type.
		MACHINE_CLEARS_MASK_COUNT = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // Number of machine clears (nukes) of any type.
		MACHINE_CLEARS_MASK_MEMORY_ORDERING = 0x0200ull, // Number of machine clears due to memory ordering conflicts.
		MACHINE_CLEARS_MASK_SMC = 0x0400ull, // Self-modifying code (SMC) detected.
		UOPS_RETIRED = 0x00c2, // Retired uops.
		UOPS_RETIRED_MASK_CYCLES = 0x0200ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles with retired uop(s).
		UOPS_RETIRED_MASK_HEAVY = 0x0100ull, // TBD
		UOPS_RETIRED_MASK_MS = 0x0800ull, // TBD
		UOPS_RETIRED_MASK_SLOTS = 0x0200ull, // Retirement slots used.
		UOPS_RETIRED_MASK_STALLS = 0x0200ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Cycles without actually retired uops.
		UOPS_RETIRED_MASK_STALL_CYCLES = 0x0200ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Cycles without actually retired uops.
		ASSISTS = 0x00c1, // Counts all microcode FP assists.
		ASSISTS_MASK_ANY = 0x1b00ull, // Number of occurrences where a microcode assist is invoked by hardware.
		ASSISTS_MASK_FP = 0x0200ull, // Counts all microcode FP assists.
		ASSISTS_MASK_PAGE_FAULT = 0x0800ull, // TBD
		ASSISTS_MASK_SSE_AVX_MIX = 0x1000ull, // TBD
		EXE = 0x02b7, // Excution cycles.
		EXE_MASK_AMX_BUSY = 0x0200ull, // Counts the cycles where the AMX (Advance Matrix Extension) unit is busy performing an operation.
		FP_ARITH_DISPATCHED = 0x00b3, // TBD
		FP_ARITH_DISPATCHED_MASK_PORT_0 = 0x0100ull, // TBD
		FP_ARITH_DISPATCHED_MASK_PORT_1 = 0x0200ull, // TBD
		FP_ARITH_DISPATCHED_MASK_PORT_5 = 0x0400ull, // TBD
		UOPS_DISPATCHED = 0x00b2, // Uops dispatched.
		UOPS_DISPATCHED_MASK_PORT_0 = 0x0100ull, // Uops executed on port 0
		UOPS_DISPATCHED_MASK_PORT_1 = 0x0200ull, // Uops executed on port 1
		UOPS_DISPATCHED_MASK_PORT_2_3_10 = 0x0400ull, // Uops executed on ports 2
		UOPS_DISPATCHED_MASK_PORT_4_9 = 0x1000ull, // Uops executed on ports 4 and 9
		UOPS_DISPATCHED_MASK_PORT_5_11 = 0x2000ull, // Uops executed on ports 5 and 11
		UOPS_DISPATCHED_MASK_PORT_6 = 0x4000ull, // Uops executed on port 6
		UOPS_DISPATCHED_MASK_PORT_7_8 = 0x8000ull, // Uops executed on ports 7 and 8
		UOPS_EXECUTED = 0x00b1, // Uops executed.
		UOPS_EXECUTED_MASK_CORE = 0x0200ull, // Number of uops executed on the core.
		UOPS_EXECUTED_MASK_CORE_CYCLES_GE_1 = 0x0200ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles at least 1 micro-op is executed from any thread on physical core.
		UOPS_EXECUTED_MASK_CORE_CYCLES_GE_2 = 0x0200ull | (0x2 << INTEL_X86_CMASK_BIT), // Cycles at least 2 micro-op is executed from any thread on physical core.
		UOPS_EXECUTED_MASK_CORE_CYCLES_GE_3 = 0x0200ull | (0x3 << INTEL_X86_CMASK_BIT), // Cycles at least 3 micro-op is executed from any thread on physical core.
		UOPS_EXECUTED_MASK_CORE_CYCLES_GE_4 = 0x0200ull | (0x4 << INTEL_X86_CMASK_BIT), // Cycles at least 4 micro-op is executed from any thread on physical core.
		UOPS_EXECUTED_MASK_CYCLES_GE_1 = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles where at least 1 uop was executed per-thread
		UOPS_EXECUTED_MASK_CYCLES_GE_2 = 0x0100ull | (0x2 << INTEL_X86_CMASK_BIT), // Cycles where at least 2 uops were executed per-thread
		UOPS_EXECUTED_MASK_CYCLES_GE_3 = 0x0100ull | (0x3 << INTEL_X86_CMASK_BIT), // Cycles where at least 3 uops were executed per-thread
		UOPS_EXECUTED_MASK_CYCLES_GE_4 = 0x0100ull | (0x4 << INTEL_X86_CMASK_BIT), // Cycles where at least 4 uops were executed per-thread
		UOPS_EXECUTED_MASK_STALLS = 0x0100ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Counts number of cycles no uops were dispatched to be executed on this thread.
		UOPS_EXECUTED_MASK_STALL_CYCLES = 0x0100ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Counts number of cycles no uops were dispatched to be executed on this thread.
		UOPS_EXECUTED_MASK_THREAD = 0x0100ull, // Counts the number of uops to be executed per-thread each cycle.
		UOPS_EXECUTED_MASK_X87 = 0x1000ull, // Counts the number of x87 uops dispatched.
		ARITH = 0x00b0, // Arithmetic operations.
		ARITH_MASK_DIVIDER_ACTIVE = 0x0900ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when divide unit is busy executing divide or square root operations.
		ARITH_MASK_DIV_ACTIVE = 0x0900ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when divide unit is busy executing divide or square root operations.
		ARITH_MASK_FPDIV_ACTIVE = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // TBD
		ARITH_MASK_FP_DIVIDER_ACTIVE = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // TBD
		ARITH_MASK_IDIV_ACTIVE = 0x0800ull, // This event counts the cycles the integer divider is busy.
		ARITH_MASK_INT_DIVIDER_ACTIVE = 0x0800ull, // This event counts the cycles the integer divider is busy.
		UOPS_ISSUED = 0x00ae, // Uops issued.
		UOPS_ISSUED_MASK_ANY = 0x0100ull, // Uops that RAT issues to RS
		INT_MISC = 0x00ad, // Miscellaneous interruptions.
		INT_MISC_MASK_CLEARS_COUNT = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // Clears speculative count
		INT_MISC_MASK_CLEAR_RESTEER_CYCLES = 0x8000ull, // Counts cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.
		INT_MISC_MASK_MBA_STALLS = 0x2000ull, // TBD
		INT_MISC_MASK_RECOVERY_CYCLES = 0x0100ull, // Core cycles the allocator was stalled due to recovery from earlier clear event for this thread
		INT_MISC_MASK_UNKNOWN_BRANCH_CYCLES = 0x0700ull, // TBD
		INT_MISC_MASK_UOP_DROPPING = 0x1000ull, // TMA slots where uops got dropped
		LSD = 0x00a8, // LSD (Loop Stream Detector) operations.
		LSD_MASK_CYCLES_ACTIVE = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles Uops delivered by the LSD
		LSD_MASK_CYCLES_OK = 0x0100ull | (0x6 << INTEL_X86_CMASK_BIT), // Cycles optimal number of Uops delivered by the LSD
		LSD_MASK_UOPS = 0x0100ull, // Number of Uops delivered by the LSD.
		EXE_ACTIVITY = 0x00a6, // Execution activity.
		EXE_ACTIVITY_MASK_1_PORTS_UTIL = 0x0200ull, // Cycles total of 1 uop is executed on all ports and Reservation Station was not empty.
		EXE_ACTIVITY_MASK_2_PORTS_UTIL = 0x0400ull, // Cycles total of 2 uops are executed on all ports and Reservation Station was not empty.
		EXE_ACTIVITY_MASK_3_PORTS_UTIL = 0x0800ull, // Cycles total of 3 uops are executed on all ports and Reservation Station was not empty.
		EXE_ACTIVITY_MASK_4_PORTS_UTIL = 0x1000ull, // Cycles total of 4 uops are executed on all ports and Reservation Station was not empty.
		EXE_ACTIVITY_MASK_BOUND_ON_LOADS = 0x2100ull | (0x5 << INTEL_X86_CMASK_BIT), // Execution stalls while memory subsystem has an outstanding load.
		EXE_ACTIVITY_MASK_BOUND_ON_STORES = 0x4000ull | (0x2 << INTEL_X86_CMASK_BIT), // Cycles where the Store Buffer was full and no loads caused an execution stall.
		RS = 0x00a5, // Reservation Station (RS) activity.
		RS_MASK_EMPTY = 0x0700ull, // Cycles when Reservation Station (RS) is empty for the thread.
		RS_MASK_EMPTY_COUNT = 0x0700ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // Counts end of periods where the Reservation Station (RS) was empty.
		CYCLE_ACTIVITY = 0x00a3, // Stalled cycles.
		CYCLE_ACTIVITY_MASK_CYCLES_L1D_MISS = 0x0800ull | (0x8 << INTEL_X86_CMASK_BIT), // Cycles while L1 cache miss demand load is outstanding.
		CYCLE_ACTIVITY_MASK_CYCLES_L2_MISS = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles while L2 cache miss demand load is outstanding.
		CYCLE_ACTIVITY_MASK_CYCLES_MEM_ANY = 0x1000ull | (0x10 << INTEL_X86_CMASK_BIT), // Cycles while memory subsystem has an outstanding load.
		CYCLE_ACTIVITY_MASK_STALLS_L1D_MISS = 0x0c00ull | (0xc << INTEL_X86_CMASK_BIT), // Execution stalls while L1 cache miss demand load is outstanding.
		CYCLE_ACTIVITY_MASK_STALLS_L2_MISS = 0x0500ull | (0x5 << INTEL_X86_CMASK_BIT), // Execution stalls while L2 cache miss demand load is outstanding.
		CYCLE_ACTIVITY_MASK_STALLS_L3_MISS = 0x0600ull | (0x6 << INTEL_X86_CMASK_BIT), // Execution stalls while L3 cache miss demand load is outstanding.
		CYCLE_ACTIVITY_MASK_STALLS_TOTAL = 0x0400ull | (0x4 << INTEL_X86_CMASK_BIT), // Total execution stalls.
		RESOURCE_STALLS = 0x00a2, // Cycles where Allocation is stalled due to Resource Related reasons.
		RESOURCE_STALLS_MASK_SB = 0x0800ull, // Cycles stalled due to no store buffers available. (not including draining form sync).
		RESOURCE_STALLS_MASK_SCOREBOARD = 0x0200ull, // Counts cycles where the pipeline is stalled due to serializing operations.
		IDQ_UOPS_NOT_DELIVERED = 0x009c, // Uops not delivered.
		IDQ_UOPS_NOT_DELIVERED_MASK_CORE = 0x0100ull, // Uops not delivered by IDQ when backend of the machine is not stalled
		IDQ_UOPS_NOT_DELIVERED_MASK_CYCLES_0_UOPS_DELIV_CORE = 0x0100ull | (0x6 << INTEL_X86_CMASK_BIT), // Cycles when no uops are not delivered by the IDQ when backend of the machine is not stalled
		IDQ_UOPS_NOT_DELIVERED_MASK_CYCLES_FE_WAS_OK = 0x0100ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when optimal number of uops was delivered to the back-end when the back-end is not stalled
		DECODE = 0x0087, // Decoder activity.
		DECODE_MASK_LCP = 0x0100ull, // Stalls caused by changing prefix length of the instruction.
		DECODE_MASK_MS_BUSY = 0x0200ull, // Cycles the Microcode Sequencer is busy.
		ICACHE_TAG = 0x0083, // Instruction cache tagging.
		ICACHE_TAG_MASK_STALLS = 0x0400ull, // Cycles where a code fetch is stalled due to L1 instruction cache tag miss.
		ICACHE_DATA = 0x0080, // Instruction cache.
		ICACHE_DATA_MASK_STALLS = 0x0400ull, // Cycles where a code fetch is stalled due to L1 instruction cache miss.
		IDQ = 0x0079, // IDQ (Instruction Decoded Queue) operations.
		IDQ_MASK_DSB_CYCLES_ANY = 0x0800ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles Decode Stream Buffer (DSB) is delivering any Uop
		IDQ_MASK_DSB_CYCLES_OK = 0x0800ull | (0x6 << INTEL_X86_CMASK_BIT), // Cycles DSB is delivering optimal number of Uops
		IDQ_MASK_DSB_UOPS = 0x0800ull, // Uops delivered to Instruction Decode Queue (IDQ) from the Decode Stream Buffer (DSB) path
		IDQ_MASK_MITE_CYCLES_ANY = 0x0400ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles MITE is delivering any Uop
		IDQ_MASK_MITE_CYCLES_OK = 0x0400ull | (0x6 << INTEL_X86_CMASK_BIT), // Cycles MITE is delivering optimal number of Uops
		IDQ_MASK_MITE_UOPS = 0x0400ull, // Uops delivered to Instruction Decode Queue (IDQ) from MITE path
		IDQ_MASK_MS_CYCLES_ANY = 0x2000ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when uops are being delivered to IDQ while MS is busy
		IDQ_MASK_MS_SWITCHES = 0x2000ull | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // Number of switches from DSB or MITE to the MS
		IDQ_MASK_MS_UOPS = 0x2000ull, // Uops delivered to IDQ while MS is busy
		UOPS_DECODED = 0x0076, // Uops decoded.
		UOPS_DECODED_MASK_DEC0_UOPS = 0x0100ull, // TBD
		INST_DECODED = 0x0075, // Instruction decoded.
		INST_DECODED_MASK_DECODERS = 0x0100ull, // Instruction decoders utilized in a cycle
		DSB2MITE_SWITCHES = 0x0061, // DSB to MITE switches.
		DSB2MITE_SWITCHES_MASK_PENALTY_CYCLES = 0x0200ull, // DSB-to-MITE switch true penalty cycles.
		TX_MEM = 0x0054, // Transactional memory.
		TX_MEM_MASK_ABORT_CAPACITY_READ = 0x8000ull, // Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional reads
		TX_MEM_MASK_ABORT_CAPACITY_WRITE = 0x0200ull, // Speculatively counts the number of TSX aborts due to a data capacity limitation for transactional writes.
		TX_MEM_MASK_ABORT_CONFLICT = 0x0100ull, // Number of times a transactional abort was signaled due to a data conflict on a transactionally accessed address
		L1D = 0x0051, // L1D cache.
		L1D_MASK_REPLACEMENT = 0x0100ull, // Counts the number of cache lines replaced in L1 data cache.
		LOAD_HIT_PREFETCH = 0x004c, // Load dispatches.
		LOAD_HIT_PREFETCH_MASK_SWPF = 0x0100ull, // Counts the number of demand load dispatches that hit L1D fill buffer (FB) allocated for software prefetch.
		L1D_PEND_MISS = 0x0048, // L1D pending misses.
		L1D_PEND_MISS_MASK_FB_FULL = 0x0200ull, // Number of cycles a demand request has waited due to L1D Fill Buffer (FB) unavailability.
		L1D_PEND_MISS_MASK_FB_FULL_PERIODS = 0x0200ull | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // Number of phases a demand request has waited due to L1D Fill Buffer (FB) unavailability.
		L1D_PEND_MISS_MASK_L2_STALL = 0x0400ull, // Number of cycles a demand request has waited due to L1D due to lack of L2 resources.
		L1D_PEND_MISS_MASK_L2_STALLS = 0x0400ull, // Number of cycles a demand request has waited due to L1D due to lack of L2 resources.
		L1D_PEND_MISS_MASK_PENDING = 0x0100ull, // Number of L1D misses that are outstanding
		L1D_PEND_MISS_MASK_PENDING_CYCLES = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles with L1D load Misses outstanding.
		MEMORY_ACTIVITY = 0x0047, // Memory activity.
		MEMORY_ACTIVITY_MASK_CYCLES_L1D_MISS = 0x0200ull | (0x2 << INTEL_X86_CMASK_BIT), // Cycles while L1 cache miss demand load is outstanding.
		MEMORY_ACTIVITY_MASK_STALLS_L1D_MISS = 0x0300ull | (0x3 << INTEL_X86_CMASK_BIT), // Execution stalls while L1 cache miss demand load is outstanding.
		MEMORY_ACTIVITY_MASK_STALLS_L2_MISS = 0x0500ull | (0x5 << INTEL_X86_CMASK_BIT), // TBD
		MEMORY_ACTIVITY_MASK_STALLS_L3_MISS = 0x0900ull | (0x9 << INTEL_X86_CMASK_BIT), // TBD
		MEM_STORE_RETIRED = 0x0044, // TBD
		MEM_STORE_RETIRED_MASK_L2_HIT = 0x0100ull, // TBD
		MEM_LOAD_COMPLETED = 0x0043, // Completed demand load.
		MEM_LOAD_COMPLETED_MASK_L1_MISS_ANY = 0xfd00ull, // Completed demand load uops that miss the L1 d-cache.
		SW_PREFETCH_ACCESS = 0x0040, // Software prefetches.
		SW_PREFETCH_ACCESS_MASK_NTA = 0x0100ull, // Number of PREFETCHNTA instructions executed.
		SW_PREFETCH_ACCESS_MASK_PREFETCHW = 0x0800ull, // Number of PREFETCHW instructions executed.
		SW_PREFETCH_ACCESS_MASK_T0 = 0x0200ull, // Number of PREFETCHT0 instructions executed.
		SW_PREFETCH_ACCESS_MASK_T1_T2 = 0x0400ull, // Number of PREFETCHT1 or PREFETCHT2 instructions executed.
		LONGEST_LAT_CACHE = 0x002e, // L3 cache.
		LONGEST_LAT_CACHE_MASK_MISS = 0x4100ull, // Core-originated cacheable requests that missed L3  (Except hardware prefetches to the L3)
		LONGEST_LAT_CACHE_MASK_REFERENCE = 0x4f00ull, // Core-originated cacheable requests that refer to L3 (Except hardware prefetches to the L3)
		XQ = 0x002d, // TBD
		XQ_MASK_FULL_CYCLES = 0x0100ull | (0x1 << INTEL_X86_CMASK_BIT), // TBD
		L2_LINES_OUT = 0x0026, // L2 lines evicted.
		L2_LINES_OUT_MASK_NON_SILENT = 0x0200ull, // TBD
		L2_LINES_OUT_MASK_SILENT = 0x0100ull, // Non-modified cache lines that are silently dropped by L2 cache when triggered by an L2 cache fill.
		L2_LINES_OUT_MASK_USELESS_HWPF = 0x0400ull, // Cache lines that have been L2 hardware prefetched but not used by demand accesses
		L2_LINES_IN = 0x0025, // L2 lines allocated.
		L2_LINES_IN_MASK_ALL = 0x1f00ull, // L2 cache lines filling L2
		L2_RQSTS = 0x0024, // L2 requests.
		L2_RQSTS_MASK_ALL_CODE_RD = 0xe400ull, // L2 code requests
		L2_RQSTS_MASK_ALL_DEMAND_DATA_RD = 0xe100ull, // Demand Data Read requests
		L2_RQSTS_MASK_ALL_DEMAND_MISS = 0x2700ull, // Demand requests that miss L2 cache
		L2_RQSTS_MASK_ALL_DEMAND_REFERENCES = 0xe700ull, // Demand requests to L2 cache
		L2_RQSTS_MASK_ALL_RFO = 0xe200ull, // RFO requests to L2 cache
		L2_RQSTS_MASK_CODE_RD_HIT = 0xc400ull, // L2 cache hits when fetching instructions
		L2_RQSTS_MASK_CODE_RD_MISS = 0x2400ull, // L2 cache misses when fetching instructions
		L2_RQSTS_MASK_DEMAND_DATA_RD_HIT = 0xc100ull, // Demand Data Read requests that hit L2 cache
		L2_RQSTS_MASK_DEMAND_DATA_RD_MISS = 0x2100ull, // Demand Data Read miss L2
		L2_RQSTS_MASK_RFO_HIT = 0xc200ull, // RFO requests that hit L2 cache
		L2_RQSTS_MASK_RFO_MISS = 0x2200ull, // RFO requests that miss L2 cache
		L2_RQSTS_MASK_SWPF_HIT = 0xc800ull, // SW prefetch requests that hit L2 cache.
		L2_RQSTS_MASK_SWPF_MISS = 0x2800ull, // SW prefetch requests that miss L2 cache.
		OFFCORE_REQUESTS = 0x0021, // Offcore requests.
		OFFCORE_REQUESTS_MASK_ALL_REQUESTS = 0x8000ull, // TBD
		OFFCORE_REQUESTS_MASK_DATA_RD = 0x0800ull, // Demand and prefetch data reads
		OFFCORE_REQUESTS_MASK_DEMAND_DATA_RD = 0x0100ull, // Demand Data Read requests sent to uncore
		OFFCORE_REQUESTS_OUTSTANDING = 0x0020, // Outstanding offcore requests.
		OFFCORE_REQUESTS_OUTSTANDING_MASK_ALL_DATA_RD = 0x0800ull, // TBD
		OFFCORE_REQUESTS_OUTSTANDING_MASK_CYCLES_WITH_DATA_RD = 0x0800ull | (0x1 << INTEL_X86_CMASK_BIT), // TBD
		OFFCORE_REQUESTS_OUTSTANDING_MASK_CYCLES_WITH_DEMAND_RFO = 0x0400ull | (0x1 << INTEL_X86_CMASK_BIT), // TBD
		OFFCORE_REQUESTS_OUTSTANDING_MASK_DATA_RD = 0x0800ull, // TBD
		DTLB_STORE_MISSES = 0x0013, // Data TLB store misses.
		DTLB_STORE_MISSES_MASK_STLB_HIT = 0x2000ull, // Stores that miss the DTLB and hit the STLB.
		DTLB_STORE_MISSES_MASK_WALK_ACTIVE = 0x1000ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when at least one PMH is busy with a page walk for a store.
		DTLB_STORE_MISSES_MASK_WALK_COMPLETED = 0x0e00ull, // Store misses in all TLB levels causes a page walk that completes. (All page sizes)
		DTLB_STORE_MISSES_MASK_WALK_COMPLETED_1G = 0x0800ull, // Page walks completed due to a demand data store to a 1G page.
		DTLB_STORE_MISSES_MASK_WALK_COMPLETED_2M_4M = 0x0400ull, // Page walks completed due to a demand data store to a 2M/4M page.
		DTLB_STORE_MISSES_MASK_WALK_COMPLETED_4K = 0x0200ull, // Page walks completed due to a demand data store to a 4K page.
		DTLB_STORE_MISSES_MASK_WALK_PENDING = 0x1000ull, // Number of page walks outstanding for a store in the PMH each cycle.
		DTLB_LOAD_MISSES = 0x0012, // Data TLB load misses.
		DTLB_LOAD_MISSES_MASK_STLB_HIT = 0x2000ull, // Loads that miss the DTLB and hit the STLB.
		DTLB_LOAD_MISSES_MASK_WALK_ACTIVE = 0x1000ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when at least one PMH is busy with a page walk for a demand load.
		DTLB_LOAD_MISSES_MASK_WALK_COMPLETED = 0x0e00ull, // Load miss in all TLB levels causes a page walk that completes. (All page sizes)
		DTLB_LOAD_MISSES_MASK_WALK_COMPLETED_1G = 0x0800ull, // Page walks completed due to a demand data load to a 1G page.
		DTLB_LOAD_MISSES_MASK_WALK_COMPLETED_2M_4M = 0x0400ull, // Page walks completed due to a demand data load to a 2M/4M page.
		DTLB_LOAD_MISSES_MASK_WALK_COMPLETED_4K = 0x0200ull, // Page walks completed due to a demand data load to a 4K page.
		DTLB_LOAD_MISSES_MASK_WALK_PENDING = 0x1000ull, // Number of page walks outstanding for a demand load in the PMH each cycle.
		ITLB_MISSES = 0x0011, // Instruction TLB misses.
		ITLB_MISSES_MASK_STLB_HIT = 0x2000ull, // Instruction fetch requests that miss the ITLB and hit the STLB.
		ITLB_MISSES_MASK_WALK_ACTIVE = 0x1000ull | (0x1 << INTEL_X86_CMASK_BIT), // Cycles when at least one PMH is busy with a page walk for code (instruction fetch) request.
		ITLB_MISSES_MASK_WALK_COMPLETED = 0x0e00ull, // Code miss in all TLB levels causes a page walk that completes. (All page sizes)
		ITLB_MISSES_MASK_WALK_COMPLETED_2M_4M = 0x0400ull, // Code miss in all TLB levels causes a page walk that completes. (2M/4M)
		ITLB_MISSES_MASK_WALK_COMPLETED_4K = 0x0200ull, // Code miss in all TLB levels causes a page walk that completes. (4K)
		ITLB_MISSES_MASK_WALK_PENDING = 0x1000ull, // Number of page walks outstanding for an outstanding code request in the PMH each cycle.
		LD_BLOCKS = 0x0003, // Blocking loads.
		LD_BLOCKS_MASK_ADDRESS_ALIAS = 0x0400ull, // False dependencies in MOB due to partial compare on address.
		LD_BLOCKS_MASK_NO_SR = 0x8800ull, // The number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.
		LD_BLOCKS_MASK_STORE_FORWARD = 0x8200ull, // Loads blocked due to overlapping with a preceding store that cannot be forwarded.
		TOPDOWN = , // Topdown events.
		TOPDOWN_MASK_BACKEND_BOUND_SLOTS = 0x0200ull, // TMA slots where no uops were being issued due to lack of back-end resources.
		TOPDOWN_MASK_BAD_SPEC_SLOTS = 0x0400ull, // TMA slots wasted due to incorrect speculations.
		TOPDOWN_MASK_BR_MISPREDICT_SLOTS = 0x0800ull, // TMA slots wasted due to incorrect speculation by branch mispredictions
		TOPDOWN_MASK_MEMORY_BOUND_SLOTS = 0x1000ull, // TBD
		TOPDOWN_MASK_SLOTS = 0x0400ull, // TMA slots available for an unhalted logical processor. Fixed counter - architectural event
		TOPDOWN_MASK_SLOTS_P = 0x01a4ull, // TMA slots available for an unhalted logical processor. General counter - architectural event
		CPU_CLK_UNHALTED = 0x003c, // Cycles in unhalted state.
		CPU_CLK_UNHALTED_MASK_C01 = 0x10ecull, // Core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.
		CPU_CLK_UNHALTED_MASK_C02 = 0x20ecull, // Core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.
		CPU_CLK_UNHALTED_MASK_C0_WAIT = 0x70ecull, // Core clocks when the thread is in the C0.1 or C0.2 or running a PAUSE in C0 ACPI state.
		CPU_CLK_UNHALTED_MASK_DISTRIBUTED = 0x02ecull, // Cycle counts are evenly distributed between active threads in the Core.
		CPU_CLK_UNHALTED_MASK_ONE_THREAD_ACTIVE = 0x0200ull, // Core crystal clock cycles when this thread is unhalted and the other thread is halted.
		CPU_CLK_UNHALTED_MASK_PAUSE = 0x40ecull, // TBD
		CPU_CLK_UNHALTED_MASK_PAUSE_INST = 0x40ecull | (0x1 << INTEL_X86_CMASK_BIT) | (0x1 << INTEL_X86_EDGE_BIT), // TBD
		CPU_CLK_UNHALTED_MASK_REF_DISTRIBUTED = 0x0800ull, // Core crystal clock cycles. Cycle counts are evenly distributed between active threads in the Core.
		CPU_CLK_UNHALTED_MASK_REF_TSC = 0x0300ull, // Reference cycles when the core is not in halt state (Fixed Counter 2).
		CPU_CLK_UNHALTED_MASK_REF_TSC_P = 0x0100ull, // Reference cycles when the core is not in halt state (Programmable Counter).
		CPU_CLK_UNHALTED_MASK_THREAD = 0x0200ull, // Core cycles when the thread is not in halt state
		CPU_CLK_UNHALTED_MASK_THREAD_P = 0x0000ull, // Thread cycles when thread is not in halt state
		INST_RETIRED = 0x00c0, // Number of instructions retired.
		INST_RETIRED_MASK_ANY = 0x0100ull, // Number of instructions retired. Fixed Counter - architectural event (c
		INST_RETIRED_MASK_STALL_CYCLES = 0x0100ull | (0x1 << INTEL_X86_INV_BIT) | (0x1 << INTEL_X86_CMASK_BIT), // Cycles without actually retired instructions.
		INST_RETIRED_MASK_ANY_P = 0x0000ull, // Number of instructions retired. General Counter - architectural event
		INST_RETIRED_MASK_MACRO_FUSED = 0x1000ull, // TBD
		INST_RETIRED_MASK_NOP = 0x0200ull, // Number of all retired NOP instructions.
		INST_RETIRED_MASK_PREC_DIST = 0x0100ull, // Precise instruction retired with PEBS precise-distribution
		INST_RETIRED_MASK_REP_ITERATION = 0x0800ull, // Iterations of Repeat string retired instructions.
		OCR = 0x012a, // Counts demand data reads that have any type of response.
		OCR_MASK_DEMAND_CODE_RD_ANY_RESPONSE = 0x1000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that have any type of response.
		OCR_MASK_DEMAND_CODE_RD_DRAM = 0x73c00000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM.
		OCR_MASK_DEMAND_CODE_RD_L3_HIT = 0x3f803c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit in the L3 or were snooped from another core's caches on the same socket.
		OCR_MASK_DEMAND_CODE_RD_L3_HIT_SNOOP_HITM = 0x10003c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OCR_MASK_DEMAND_CODE_RD_L3_MISS = 0x3fbfc0000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were not supplied by the local socket's L1
		OCR_MASK_DEMAND_CODE_RD_LOCAL_DRAM = 0x10400000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM attached to this socket
		OCR_MASK_DEMAND_CODE_RD_SNC_CACHE_HITM = 0x100800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_CODE_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_CODE_RD_SNC_DRAM = 0x70800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_DATA_RD_ANY_RESPONSE = 0x1000100ull, // Counts demand data reads that have any type of response.
		OCR_MASK_DEMAND_DATA_RD_DRAM = 0x73c00000100ull, // Counts demand data reads that were supplied by DRAM.
		OCR_MASK_DEMAND_DATA_RD_L3_HIT = 0x3f803c000100ull, // Counts demand data reads that hit in the L3 or were snooped from another core's caches on the same socket.
		OCR_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HITM = 0x10003c000100ull, // Counts demand data reads that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OCR_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c000100ull, // Counts demand data reads that resulted in a snoop that hit in another core
		OCR_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c000100ull, // Counts demand data reads that resulted in a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OCR_MASK_DEMAND_DATA_RD_L3_MISS = 0x3fbfc0000100ull, // Counts demand data reads that were not supplied by the local socket's L1
		OCR_MASK_DEMAND_DATA_RD_LOCAL_DRAM = 0x10400000100ull, // Counts demand data reads that were supplied by DRAM attached to this socket
		OCR_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HITM = 0x103000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit a modified line in another core's caches which forwarded the data.
		OCR_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OCR_MASK_DEMAND_DATA_RD_REMOTE_DRAM = 0x73000000100ull, // Counts demand data reads that were supplied by DRAM attached to another socket.
		OCR_MASK_DEMAND_DATA_RD_REMOTE_PMM = 0x70300000100ull, // Counts demand data reads that were supplied by PMM attached to another socket.
		OCR_MASK_DEMAND_DATA_RD_SNC_CACHE_HITM = 0x100800000100ull, // Counts demand data reads that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_DATA_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000100ull, // Counts demand data reads that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_DATA_RD_SNC_DRAM = 0x70800000100ull, // Counts demand data reads that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_RFO_ANY_RESPONSE = 0x3f3ffc000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that have any type of response.
		OCR_MASK_DEMAND_RFO_DRAM = 0x73c00000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM.
		OCR_MASK_DEMAND_RFO_L3_HIT = 0x3f803c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit in the L3 or were snooped from another core's caches on the same socket.
		OCR_MASK_DEMAND_RFO_L3_HIT_SNOOP_HITM = 0x10003c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OCR_MASK_DEMAND_RFO_L3_MISS = 0x3f3fc0000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were not supplied by the local socket's L1
		OCR_MASK_DEMAND_RFO_LOCAL_DRAM = 0x10400000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM attached to this socket
		OCR_MASK_DEMAND_RFO_SNC_CACHE_HITM = 0x100800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_RFO_SNC_CACHE_HIT_WITH_FWD = 0x80800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_DEMAND_RFO_SNC_DRAM = 0x70800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OCR_MASK_HWPF_L1D_ANY_RESPONSE = 0x1040000ull, // Counts data load hardware prefetch requests to the L1 data cache that have any type of response.
		OCR_MASK_HWPF_L2_ANY_RESPONSE = 0x1007000ull, // Counts hardware prefetches (which bring data to L2) that have any type of response.
		OCR_MASK_HWPF_L3_ANY_RESPONSE = 0x1238000ull, // Counts hardware prefetches to the L3 only that have any type of response.
		OCR_MASK_HWPF_L3_L3_HIT = 0x8008238000ull, // Counts hardware prefetches to the L3 only that hit in the L3 or were snooped from another core's caches on the same socket.
		OCR_MASK_HWPF_L3_L3_MISS = 0x9400238000ull, // Counts hardware prefetches to the L3 only that missed the local socket's L1
		OCR_MASK_HWPF_L3_L3_MISS_LOCAL = 0x8400238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OCR_MASK_HWPF_L3_REMOTE = 0x9000238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OCR_MASK_MODIFIED_WRITE_ANY_RESPONSE = 0x1080800ull, // Counts writebacks of modified cachelines and streaming stores that have any type of response.
		OCR_MASK_READS_TO_CORE_ANY_RESPONSE = 0x3f3ffc447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_DRAM = 0x73c00447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_HIT = 0x3f003c447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_HIT_SNOOP_HITM = 0x10003c447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_MISS = 0x3f3fc0447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_MISS_LOCAL = 0x3f04c0447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_L3_MISS_LOCAL_SOCKET = 0x70cc0447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_LOCAL_DRAM = 0x10400447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_LOCAL_SOCKET_DRAM = 0x70c00447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_LOCAL_SOCKET_PMM = 0x700c0447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE = 0x3f3300447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_FWD = 0x183000447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HITM = 0x103000447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_DRAM = 0x73000447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_MEMORY = 0x73300447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_REMOTE_PMM = 0x70300447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_SNC_CACHE_HITM = 0x100800447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_SNC_CACHE_HIT_WITH_FWD = 0x80800447700ull, // Counts all (cacheable) data read
		OCR_MASK_READS_TO_CORE_SNC_DRAM = 0x70800447700ull, // Counts all (cacheable) data read
		OCR_MASK_RFO_TO_CORE_L3_HIT_M = 0x1f8004002200ull, // Counts demand reads for ownership (RFO)
		OCR_MASK_STREAMING_WR_ANY_RESPONSE = 0x1080000ull, // Counts streaming stores that have any type of response.
		OCR_MASK_STREAMING_WR_L3_HIT = 0x8008080000ull, // Counts streaming stores that hit in the L3 or were snooped from another core's caches on the same socket.
		OCR_MASK_STREAMING_WR_L3_MISS = 0x9400080000ull, // Counts streaming stores that missed the local socket's L1
		OCR_MASK_STREAMING_WR_L3_MISS_LOCAL = 0x8400080000ull, // Counts streaming stores that were not supplied by the local socket's L1
		OCR_MASK_WRITE_ESTIMATE_MEMORY = 0xfbff8082200ull, // Counts Demand RFOs
		OFFCORE_RESPONSE_0 = 0x012a, // Offcore response event
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_ANY_RESPONSE = 0x1000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that have any type of response.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_DRAM = 0x73c00000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_L3_HIT = 0x3f803c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_L3_HIT_SNOOP_HITM = 0x10003c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_L3_MISS = 0x3fbfc0000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_LOCAL_DRAM = 0x10400000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_SNC_CACHE_HITM = 0x100800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_CODE_RD_SNC_DRAM = 0x70800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_ANY_RESPONSE = 0x1000100ull, // Counts demand data reads that have any type of response.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_DRAM = 0x73c00000100ull, // Counts demand data reads that were supplied by DRAM.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_L3_HIT = 0x3f803c000100ull, // Counts demand data reads that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HITM = 0x10003c000100ull, // Counts demand data reads that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c000100ull, // Counts demand data reads that resulted in a snoop that hit in another core
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c000100ull, // Counts demand data reads that resulted in a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_L3_MISS = 0x3fbfc0000100ull, // Counts demand data reads that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_LOCAL_DRAM = 0x10400000100ull, // Counts demand data reads that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HITM = 0x103000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_REMOTE_DRAM = 0x73000000100ull, // Counts demand data reads that were supplied by DRAM attached to another socket.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_REMOTE_PMM = 0x70300000100ull, // Counts demand data reads that were supplied by PMM attached to another socket.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_SNC_CACHE_HITM = 0x100800000100ull, // Counts demand data reads that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000100ull, // Counts demand data reads that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_DATA_RD_SNC_DRAM = 0x70800000100ull, // Counts demand data reads that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_ANY_RESPONSE = 0x3f3ffc000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that have any type of response.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_DRAM = 0x73c00000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_L3_HIT = 0x3f803c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_L3_HIT_SNOOP_HITM = 0x10003c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_L3_MISS = 0x3f3fc0000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_LOCAL_DRAM = 0x10400000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_SNC_CACHE_HITM = 0x100800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_SNC_CACHE_HIT_WITH_FWD = 0x80800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_DEMAND_RFO_SNC_DRAM = 0x70800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_0_MASK_HWPF_L1D_ANY_RESPONSE = 0x1040000ull, // Counts data load hardware prefetch requests to the L1 data cache that have any type of response.
		OFFCORE_RESPONSE_0_MASK_HWPF_L2_ANY_RESPONSE = 0x1007000ull, // Counts hardware prefetches (which bring data to L2) that have any type of response.
		OFFCORE_RESPONSE_0_MASK_HWPF_L3_ANY_RESPONSE = 0x1238000ull, // Counts hardware prefetches to the L3 only that have any type of response.
		OFFCORE_RESPONSE_0_MASK_HWPF_L3_L3_HIT = 0x8008238000ull, // Counts hardware prefetches to the L3 only that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_0_MASK_HWPF_L3_L3_MISS = 0x9400238000ull, // Counts hardware prefetches to the L3 only that missed the local socket's L1
		OFFCORE_RESPONSE_0_MASK_HWPF_L3_L3_MISS_LOCAL = 0x8400238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_HWPF_L3_REMOTE = 0x9000238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_MODIFIED_WRITE_ANY_RESPONSE = 0x1080800ull, // Counts writebacks of modified cachelines and streaming stores that have any type of response.
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_ANY_RESPONSE = 0x3f3ffc447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_DRAM = 0x73c00447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_HIT = 0x3f003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_HIT_SNOOP_HITM = 0x10003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_MISS = 0x3f3fc0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_MISS_LOCAL = 0x3f04c0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_L3_MISS_LOCAL_SOCKET = 0x70cc0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_LOCAL_DRAM = 0x10400447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_LOCAL_SOCKET_DRAM = 0x70c00447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_LOCAL_SOCKET_PMM = 0x700c0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE = 0x3f3300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_FWD = 0x183000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HITM = 0x103000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_DRAM = 0x73000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_MEMORY = 0x73300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_REMOTE_PMM = 0x70300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_SNC_CACHE_HITM = 0x100800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_SNC_CACHE_HIT_WITH_FWD = 0x80800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_READS_TO_CORE_SNC_DRAM = 0x70800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_0_MASK_RFO_TO_CORE_L3_HIT_M = 0x1f8004002200ull, // Counts demand reads for ownership (RFO)
		OFFCORE_RESPONSE_0_MASK_STREAMING_WR_ANY_RESPONSE = 0x1080000ull, // Counts streaming stores that have any type of response.
		OFFCORE_RESPONSE_0_MASK_STREAMING_WR_L3_HIT = 0x8008080000ull, // Counts streaming stores that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_0_MASK_STREAMING_WR_L3_MISS = 0x9400080000ull, // Counts streaming stores that missed the local socket's L1
		OFFCORE_RESPONSE_0_MASK_STREAMING_WR_L3_MISS_LOCAL = 0x8400080000ull, // Counts streaming stores that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_0_MASK_WRITE_ESTIMATE_MEMORY = 0xfbff8082200ull, // Counts Demand RFOs
		OFFCORE_RESPONSE_1 = 0x012b, // Offcore response event
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_ANY_RESPONSE = 0x1000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that have any type of response.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_DRAM = 0x73c00000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_L3_HIT = 0x3f803c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_L3_HIT_SNOOP_HITM = 0x10003c000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_L3_MISS = 0x3fbfc0000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_LOCAL_DRAM = 0x10400000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_SNC_CACHE_HITM = 0x100800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_CODE_RD_SNC_DRAM = 0x70800000400ull, // Counts demand instruction fetches and L1 instruction cache prefetches that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_ANY_RESPONSE = 0x1000100ull, // Counts demand data reads that have any type of response.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_DRAM = 0x73c00000100ull, // Counts demand data reads that were supplied by DRAM.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_L3_HIT = 0x3f803c000100ull, // Counts demand data reads that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HITM = 0x10003c000100ull, // Counts demand data reads that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c000100ull, // Counts demand data reads that resulted in a snoop that hit in another core
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c000100ull, // Counts demand data reads that resulted in a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_L3_MISS = 0x3fbfc0000100ull, // Counts demand data reads that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_LOCAL_DRAM = 0x10400000100ull, // Counts demand data reads that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HITM = 0x103000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000000100ull, // Counts demand data reads that were supplied by a cache on a remote socket where a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_REMOTE_DRAM = 0x73000000100ull, // Counts demand data reads that were supplied by DRAM attached to another socket.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_REMOTE_PMM = 0x70300000100ull, // Counts demand data reads that were supplied by PMM attached to another socket.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_SNC_CACHE_HITM = 0x100800000100ull, // Counts demand data reads that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_SNC_CACHE_HIT_WITH_FWD = 0x80800000100ull, // Counts demand data reads that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_DATA_RD_SNC_DRAM = 0x70800000100ull, // Counts demand data reads that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_ANY_RESPONSE = 0x3f3ffc000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that have any type of response.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_DRAM = 0x73c00000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_L3_HIT = 0x3f803c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_L3_HIT_SNOOP_HITM = 0x10003c000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that resulted in a snoop hit a modified line in another core's caches which forwarded the data.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_L3_MISS = 0x3f3fc0000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_LOCAL_DRAM = 0x10400000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM attached to this socket
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_SNC_CACHE_HITM = 0x100800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that hit a modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_SNC_CACHE_HIT_WITH_FWD = 0x80800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that either hit a non-modified line in a distant L3 Cache or were snooped from a distant core's L1/L2 caches on this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_DEMAND_RFO_SNC_DRAM = 0x70800000200ull, // Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.
		OFFCORE_RESPONSE_1_MASK_HWPF_L1D_ANY_RESPONSE = 0x1040000ull, // Counts data load hardware prefetch requests to the L1 data cache that have any type of response.
		OFFCORE_RESPONSE_1_MASK_HWPF_L2_ANY_RESPONSE = 0x1007000ull, // Counts hardware prefetches (which bring data to L2) that have any type of response.
		OFFCORE_RESPONSE_1_MASK_HWPF_L3_ANY_RESPONSE = 0x1238000ull, // Counts hardware prefetches to the L3 only that have any type of response.
		OFFCORE_RESPONSE_1_MASK_HWPF_L3_L3_HIT = 0x8008238000ull, // Counts hardware prefetches to the L3 only that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_1_MASK_HWPF_L3_L3_MISS = 0x9400238000ull, // Counts hardware prefetches to the L3 only that missed the local socket's L1
		OFFCORE_RESPONSE_1_MASK_HWPF_L3_L3_MISS_LOCAL = 0x8400238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_HWPF_L3_REMOTE = 0x9000238000ull, // Counts hardware prefetches to the L3 only that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_MODIFIED_WRITE_ANY_RESPONSE = 0x1080800ull, // Counts writebacks of modified cachelines and streaming stores that have any type of response.
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_ANY_RESPONSE = 0x3f3ffc447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_DRAM = 0x73c00447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_HIT = 0x3f003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_HIT_SNOOP_HITM = 0x10003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_NO_FWD = 0x4003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_HIT_SNOOP_HIT_WITH_FWD = 0x8003c447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_MISS = 0x3f3fc0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_MISS_LOCAL = 0x3f04c0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_L3_MISS_LOCAL_SOCKET = 0x70cc0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_LOCAL_DRAM = 0x10400447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_LOCAL_SOCKET_DRAM = 0x70c00447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_LOCAL_SOCKET_PMM = 0x700c0447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE = 0x3f3300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_FWD = 0x183000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HITM = 0x103000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_CACHE_SNOOP_HIT_WITH_FWD = 0x83000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_DRAM = 0x73000447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_MEMORY = 0x73300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_REMOTE_PMM = 0x70300447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_SNC_CACHE_HITM = 0x100800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_SNC_CACHE_HIT_WITH_FWD = 0x80800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_READS_TO_CORE_SNC_DRAM = 0x70800447700ull, // Counts all (cacheable) data read
		OFFCORE_RESPONSE_1_MASK_RFO_TO_CORE_L3_HIT_M = 0x1f8004002200ull, // Counts demand reads for ownership (RFO)
		OFFCORE_RESPONSE_1_MASK_STREAMING_WR_ANY_RESPONSE = 0x1080000ull, // Counts streaming stores that have any type of response.
		OFFCORE_RESPONSE_1_MASK_STREAMING_WR_L3_HIT = 0x8008080000ull, // Counts streaming stores that hit in the L3 or were snooped from another core's caches on the same socket.
		OFFCORE_RESPONSE_1_MASK_STREAMING_WR_L3_MISS = 0x9400080000ull, // Counts streaming stores that missed the local socket's L1
		OFFCORE_RESPONSE_1_MASK_STREAMING_WR_L3_MISS_LOCAL = 0x8400080000ull, // Counts streaming stores that were not supplied by the local socket's L1
		OFFCORE_RESPONSE_1_MASK_WRITE_ESTIMATE_MEMORY = 0xfbff8082200ull, // Counts Demand RFOs
		
	};
};