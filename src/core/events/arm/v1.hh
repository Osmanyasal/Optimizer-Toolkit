#include <cstdint>

namespace optkit::arm{
	enum class v1 : uint64_t {
		SW_INCR = 0x00, // Instruction architecturally executed (condition check pass) software increment
		L1I_CACHE_REFILL = 0x01, // Level 1 instruction cache refills
		L1I_TLB_REFILL = 0x02, // Level 1 instruction TLB refills
		L1D_CACHE_REFILL = 0x03, // Level 1 data cache refills
		L1D_CACHE = 0x04, // Level 1 data cache accesses
		L1D_TLB_REFILL = 0x05, // Level 1 data TLB refills
		INST_RETIRED = 0x08, // Instructions architecturally executed
		EXC_TAKEN = 0x09, // Exceptions taken
		EXC_RETURN = 0x0a, // Instructions architecturally executed (condition check pass) - Exception return
		CID_WRITE_RETIRED = 0x0b, // Instructions architecturally executed (condition check pass) - Write to CONTEXTIDR
		BR_MIS_PRED = 0x10, // Mispredicted or not predicted branches speculatively executed
		CPU_CYCLES = 0x11, // Cycles
		BR_PRED = 0x12, // Predictable branches speculatively executed
		MEM_ACCESS = 0x13, // Data memory accesses
		L1I_CACHE_ACCESS = 0x14, // Level 1 instruction cache accesses
		L1D_CACHE_WB = 0x15, // Level 1 data cache write-backs
		L2D_CACHE_ACCESS = 0x16, // Level 2 data cache accesses
		L2D_CACHE_REFILL = 0x17, // Level 2 data cache refills
		L2D_CACHE_WB = 0x18, // Level 2 data cache write-backs
		BUS_ACCESS = 0x19, // Counts every beat of data transferred over the data channels between the core and the SCU
		MEMORY_ERROR = 0x1a, // Local memory errors
		INST_SPEC = 0x1b, // Instructions speculatively executed
		TTBR_WRITE_RETIRED = 0x1c, // Instructions architecturally executed (condition check pass
		BUS_MASTER_CYCLE = 0x1d, // Bus cycles. This event duplicate cycles
		COUNTER_OVERFLOW = 0x1e, // For odd-numbered counters
		L2D_CACHE_ALLOCATE = 0x20, // Level 2 data/unified cache allocations without refill
		BR_RETIRED = 0x21, // Counts all branches on the architecturally executed path that would incur cost if mispredicted
		BR_MIS_PRED_RETIRED = 0x22, // Instructions executed
		STALL_FRONTEND = 0x23, // Cycles in which no operation issued because there were no operations to issue
		STALL_BACKEND = 0x24, // Cycles in which no operation issued due to back-end resources being unavailable
		L1D_TLB = 0x25, // Level 1 data TLB accesses
		L1I_TLB = 0x26, // Instruction TLB accesses
		L2D_TLB_REFILL = 0x2d, // Attributable L2 data or unified TLB refills. Counts on any refill of the L2TLB caused by either an instruction or data access (MMU must be enabled)
		L2D_TLB_REQ = 0x2f, // Attributable L2 TLB accesses. Counts on any access to the MMUTC (caused by a refill of any of the L1 TLBs). This event does not count if the MMU is disabled
		L2D_TLB = 0x2f, // Attributable L2 TLB accesses. Counts on any access to the MMUTC (caused by a refill of any of the L1 TLBs). This event does not count if the MMU is disabled
		REMOTE_ACCESS = 0x31, // Number of accesses to another socket
		DTLB_WALK = 0x34, // Accesses to the data TLB that caused a page walk. Counts any data access which causes L2D_TLB_REFILL to count
		ITLB_WALK = 0x35, // Accesses to the instruction TLB that caused a page walk. Counts any instruction which causes L2D_TLB_REFILL to count
		LL_CACHE_RD = 0x36, // Last Level cache accesses for reads
		LL_CACHE_MISS_RD = 0x37, // Last Level cache misses for reads
		L1D_CACHE_LMISS_RD = 0x39, // Counts the number Level 1 data cache long-latency misses
		OP_RETIRED = 0x3a, // Counts the number of micro-ops architecturally executed
		OP_SPEC = 0x3b, // Counts the number of speculatively executed micro-ops
		STALL = 0x3c, // Counts cycles in which no operation is sent for execution
		STALL_SLOT_BACKEND = 0x3d, // No operation sent for execution on a slot due to the backend
		STALL_SLOT_FRONTEND = 0x3e, // No operation sent for execution on a slot due to the frontend
		STALL_SLOT = 0x3f, // No operation sent for execution on a slot
		L1D_CACHE_RD = 0x40, // Level 1 data cache read accesses
		L1D_CACHE_WR = 0x41, // Level 1 data cache write accesses
		L1D_CACHE_REFILL_RD = 0x42, // Level 1 data cache read refills
		L1D_CACHE_REFILL_WR = 0x43, // Level 1 data cache write refills
		L1D_CACHE_REFILL_INNER = 0x44, // Level 1 data cache refills
		L1D_CACHE_REFILL_OUTER = 0x45, // Level 1 data cache refills
		L1D_CACHE_WB_VICTIM = 0x46, // Level 1 data cache write-backs (victim eviction)
		L1D_CACHE_WB_CLEAN = 0x47, // Level 1 data cache write-backs (clean and coherency eviction)
		L1D_CACHE_INVAL = 0x48, // Level 1 data cache invalidations
		L1D_TLB_REFILL_RD = 0x4c, // Level 1 data TLB read refills
		L1D_TLB_REFILL_WR = 0x4d, // Level 1 data TLB write refills
		L1D_TLB_RD = 0x4e, // Level 1 data TLB read accesses
		L1D_TLB_WR = 0x4f, // Level 1 data TLB write accesses
		L2D_CACHE_RD = 0x50, // Level 2 data cache read accesses
		L2D_CACHE_WR = 0x51, // Level 2 data cache write accesses
		L2D_CACHE_REFILL_RD = 0x52, // Level 2 data cache read refills
		L2D_CACHE_REFILL_WR = 0x53, // Level 2 data cache write refills
		L2D_CACHE_WB_VICTIM = 0x56, // Level 2 data cache victim write-backs
		L2D_CACHE_WB_CLEAN = 0x57, // Level 2 data cache cleaning and coherency write-backs
		L2D_CACHE_INVAL = 0x58, // Level 2 data cache invalidations
		L2D_TLB_REFILL_RD = 0x5c, // Level 2 data TLB refills on read
		L2D_TLB_REFILL_WR = 0x5d, // Level 2 data TLB refills on write
		L2D_TLB_RD = 0x5e, // Level 2 data TLB accesses on read
		L2D_TLB_WR = 0x5f, // Level 2 data TLB accesses on write
		BUS_ACCESS_RD = 0x60, // Bus read accesses
		BUS_ACCESS_WR = 0x61, // Bus write accesses
		MEM_ACCESS_RD = 0x66, // Data memory read accesses (includes SVE)
		MEM_READ_ACCESS = 0x66, // Data memory read accesses
		MEM_ACCESS_WR = 0x67, // Data memory write accesses (includes SVE)
		MEM_WRITE_ACCESS = 0x67, // Data memory write accesses
		UNALIGNED_LD_SPEC = 0x68, // Unaligned read accesses
		UNALIGNED_ST_SPEC = 0x69, // Unaligned write accesses
		UNALIGNED_LDST_SPEC = 0x6a, // Unaligned accesses (includes speculatively executed SVE load and store operations that access at least one unaligned element address)
		UNALIGNED_LDST_ACCESS = 0x6a, // Unaligned accesses
		LDREX_SPEC = 0x6c, // Exclusive operations speculatively executed - LDREX or LDX
		STREX_PASS_SPEC = 0x6d, // Exclusive operations speculative executed - STREX or STX pass
		STREX_FAIL_SPEC = 0x6e, // Exclusive operations speculative executed - STREX or STX fail
		STREX_SPEC = 0x6f, // Exclusive operations speculatively executed - STREX or STX
		LD_SPEC = 0x70, // Load instructions speculatively executed
		ST_SPEC = 0x71, // Store instructions speculatively executed
		DP_SPEC = 0x73, // Integer data processing instructions speculatively executed
		ASE_SPEC = 0x74, // Advanced SIMD instructions speculatively executed
		VFP_SPEC = 0x75, // Floating-point instructions speculatively executed
		PC_WRITE_SPEC = 0x76, // Software change of the PC instruction speculatively executed
		CRYPTO_SPEC = 0x77, // Cryptographic instructions speculatively executed
		BR_IMMED_SPEC = 0x78, // Immediate branches speculatively executed
		BR_RET_SPEC = 0x79, // Return branches speculatively executed
		BR_RETURN_SPEC = 0x79, // Return branches speculatively executed
		BR_INDIRECT_SPEC = 0x7a, // Indirect branches speculatively executed
		ISB_SPEC = 0x7c, // ISB barriers speculatively executed
		DSB_SPEC = 0x7d, // DSB barriers speculatively executed
		DMB_SPEC = 0x7e, // DMB barriers speculatively executed
		EXC_UNDEF = 0x81, // Undefined exceptions taken locally
		EXC_SVC = 0x82, // Exceptions taken
		EXC_PABORT = 0x83, // Exceptions taken
		EXC_DABORT = 0x84, // Exceptions taken locally
		EXC_IRQ = 0x86, // Exceptions taken locally
		EXC_FIQ = 0x87, // Exceptions taken locally
		EXC_SMC = 0x88, // Exceptions taken locally
		EXC_HVC = 0x8a, // Exceptions taken
		EXC_TRAP_PABORT = 0x8b, // Exceptions taken
		EXC_TRAP_DABORT = 0x8c, // Exceptions taken
		EXC_TRAP_OTHER = 0x8d, // Exceptions taken
		EXC_TRAP_IRQ = 0x8e, // Exceptions taken
		EXC_TRAP_FIQ = 0x8f, // Exceptions taken
		RC_LD_SPEC = 0x90, // Release consistency instructions speculatively executed (load-acquire)
		RC_ST_SPEC = 0x91, // Release consistency instructions speculatively executed (store-release)
		SAMPLE_POP = 0x4000, // Number of operations that might be sampled by SPE
		SAMPLE_FEED = 0x4001, // Number of times the SPE sample interval counter reaches zero and is reloaded
		SAMPLE_FILTRATE = 0x4002, // Number of times SPE completed sample record passes the SPE filters and is written to the buffer
		SAMPLE_COLLISION = 0x4003, // Number of times SPE has a sample record taken when the previous sampled operation has not yet completed its record
		CNT_CYCLES = 0x4004, // Constant frequency cycles
		STALL_BACKEND_MEM = 0x4005, // No operation sent due to the backend and memory stalls
		L1I_CACHE_LMISS = 0x4006, // Counts L1 instruction cache long latency misses
		L2D_CACHE_LMISS_RD = 0x4009, // Counts L2 cache long latency misses
		ASE_INST_SPEC = 0x8005, // Advanced SIMD operations sepculatively executed
		SVE_INST_SPEC = 0x8006, // SVE operations sepculatively executed
		SVE_PRED_SPEC = 0x8074, // SVE predicated operations speculatively executed
		SVE_PRED_EMPTY_SPEC = 0x8075, // SVE predicated operations with no active predicates speculatively executed
		SVE_PRED_FULL_SPEC = 0x8076, // SVE predicated operations with all active predicates speculatively executed
		SVE_PRED_PARTIAL_SPEC = 0x8077, // SVE predicated operations with partially active predicates speculatively executed
		SVE_LDFF_SPEC = 0x80bc, // SVE first-fault load operations speculatively executed
		SVE_LDFF_FAULT_SPEC = 0x80bd, // SVE first-fault load operations speculatively executed which set FFR bit to 0
		FP_SCALE_OPS_SPEC = 0x80c0, // Scalable floating-point element operations sepculatively executed
		FP_FIXED_OPS_SPEC = 0x80c1, // Non-scalable floating-point element operations sepculatively executed
		
	};
};