#include <cstdint>
namespace optkit::arm::a64fx{
	enum a64fx : uint64_t {
		SW_INCR = 0x0000, // This event counts on writes to the PMSWINC register.
		L1I_CACHE_REFILL = 0x0001, // This event counts operations that cause a refill of at least the L1I cache.
		L1I_TLB_REFILL = 0x0002, // This event counts operations that cause a TLB refill of at least the L1I TLB.
		L1D_CACHE_REFILL = 0x0003, // This event counts operations that cause a refill of at least the L1D cache.
		L1D_CACHE = 0x0004, // This event counts operations that cause a cache access to at least the L1D cache.
		L1D_TLB_REFILL = 0x0005, // This event counts operations that cause a TLB refill of at least the L1D TLB.
		INST_RETIRED = 0x0008, // This event counts every architecturally executed instruction.
		EXC_TAKEN = 0x0009, // This event counts each exception taken.
		EXC_RETURN = 0x000a, // This event counts each executed exception return instruction.
		CID_WRITE_RETIRED = 0x000b, // This event counts every write to CONTEXTIDR.
		BR_MIS_PRED = 0x0010, // This event counts each correction to the predicted program flow that occurs because of a misprediction from
		CPU_CYCLES = 0x0011, // This event counts every cycle.
		BR_PRED = 0x0012, // This event counts every branch or other change in the program flow that the branch prediction resources are capable of predicting.
		L1I_CACHE = 0x0014, // This event counts operations that cause a cache access to at least the L1I cache.
		L1D_CACHE_WB = 0x0015, // This event counts every write-back of data from the L1D cache.
		L2D_CACHE = 0x0016, // This event counts operations that cause a cache access to at least the L2 cache.
		L2D_CACHE_REFILL = 0x0017, // This event counts operations that cause a refill of at least the L2 cache.
		L2D_CACHE_WB = 0x0018, // This event counts every write-back of data from the L2 cache.
		INST_SPEC = 0x001b, // This event counts every architecturally executed instruction.
		STALL_FRONTEND = 0x0023, // This event counts every cycle counted by the CPU_CYCLES event on that no operations are issued because there are no operations available to issue for this PE from the frontend.
		STALL_BACKEND = 0x0024, // This event counts every cycle counted by the CPU_CYCLES event on that no operations are issued because the backend is unable to accept any operations.
		L2D_TLB_REFILL = 0x002d, // This event counts operations that cause a TLB refill of at least the L2D TLB.
		L2I_TLB_REFILL = 0x002e, // This event counts operations that cause a TLB refill of at least the L2I TLB.
		L2D_TLB = 0x002f, // This event counts operations that cause a TLB access to at least the L2D TLB.
		L2I_TLB = 0x0030, // This event counts operations that cause a TLB access to at least the L2I TLB.
		L1D_CACHE_REFILL_PRF = 0x0049, // This event counts L1D_CACHE_REFILL caused by software or hardware prefetch.
		L2D_CACHE_REFILL_PRF = 0x0059, // This event counts L2D_CACHE_REFILL caused by software or hardware prefetch.
		LDREX_SPEC = 0x006c, // This event counts architecturally executed load-exclusive instructions.
		STREX_SPEC = 0x006f, // This event counts architecturally executed store-exclusive instructions.
		LD_SPEC = 0x0070, // This event counts architecturally executed memory-reading instructions
		ST_SPEC = 0x0071, // This event counts architecturally executed memory-writing instructions
		LDST_SPEC = 0x0072, // This event counts architecturally executed memory-reading instructions and memory-writing instructions
		DP_SPEC = 0x0073, // This event counts architecturally executed integer data-processing instructions.
		ASE_SPEC = 0x0074, // This event counts architecturally executed Advanced SIMD data-processing instructions.
		VFP_SPEC = 0x0075, // This event counts architecturally executed floating-point data-processing instructions.
		PC_WRITE_SPEC = 0x0076, // This event counts only software changes of the PC that defined by the instruction architecturally executed
		CRYPTO_SPEC = 0x0077, // This event counts architecturally executed cryptographic instructions
		BR_IMMED_SPEC = 0x0078, // This event counts architecturally executed immediate branch instructions.
		BR_RETURN_SPEC = 0x0079, // This event counts architecturally executed procedure return operations that defined by the BR_RETURN_RETIRED event.
		BR_INDIRECT_SPEC = 0x007a, // This event counts architecturally executed indirect branch instructions that includes software change of the PC other than exception-generating instructions and immediate branch instructions.
		ISB_SPEC = 0x007c, // This event counts architecturally executed Instruction Synchronization Barrier instructions.
		DSB_SPEC = 0x007d, // This event counts architecturally executed Data Synchronization Barrier instructions.
		DMB_SPEC = 0x007e, // This event counts architecturally executed Data Memory Barrier instructions
		EXC_UNDEF = 0x0081, // This event counts only other synchronous exceptions that are taken locally.
		EXC_SVC = 0x0082, // This event counts only Supervisor Call exceptions that are taken locally.
		EXC_PABORT = 0x0083, // This event counts only Instruction Abort exceptions that are taken locally.
		EXC_DABORT = 0x0084, // This event counts only Data Abort or SError interrupt exceptions that are taken locally.
		EXC_IRQ = 0x0086, // This event counts only IRQ exceptions that are taken locally
		EXC_FIQ = 0x0087, // This event counts only FIQ exceptions that are taken locally
		EXC_SMC = 0x0088, // This event counts only Secure Monitor Call exceptions. The counter does not increment on SMC instructions trapped as a Hyp Trap exception.
		EXC_HVC = 0x008a, // This event counts for both Hypervisor Call exceptions taken locally in the hypervisor and those taken as an exception from Non-secure EL1.
		DCZVA_SPEC = 0x009f, // This event counts architecturally executed zero blocking operations due to the 'DC ZVA' instruction.
		FP_MV_SPEC = 0x0105, // This event counts architecturally executed floating-point move operations.
		PRD_SPEC = 0x0108, // This event counts architecturally executed operations that using predicate register.
		IEL_SPEC = 0x0109, // This event counts architecturally executed inter-element manipulation operations.
		IREG_SPEC = 0x010a, // This event counts architecturally executed inter-register manipulation operations.
		FP_LD_SPEC = 0x0112, // This event counts architecturally executed NOSIMD load operations that using SIMD and FP registers.
		FP_ST_SPEC = 0x0113, // This event counts architecturally executed NOSIMD store operations that using SIMD and FP registers.
		BC_LD_SPEC = 0x011a, // This event counts architecturally executed SIMD broadcast floating-point load operations.
		EFFECTIVE_INST_SPEC = 0x0121, // This event counts architecturally executed instructions
		PRE_INDEX_SPEC = 0x0123, // This event counts architecturally executed operations that uses 'pre-index' as its addressing mode.
		POST_INDEX_SPEC = 0x0124, // This event counts architecturally executed operations that uses 'post-index' as its addressing mode.
		UOP_SPLIT = 0x0139, // This event counts the occurrence count of the micro-operation split.
		LD_COMP_WAIT_L2_MISS = 0x0180, // This event counts every cycle that no operation was committed because the oldest and uncommitted load/store operation waits for memory access.
		LD_COMP_WAIT_L2_MISS_EX = 0x0181, // This event counts every cycle that no instructions are committed because the oldest and uncommitted integer load instruction waits for memory access.
		LD_COMP_WAIT_L1_MISS = 0x0182, // This event counts every cycle that no instruction was committed because the oldest and uncommitted load/store operation waits for L2 cache access.
		LD_COMP_WAIT_L1_MISS_EX = 0x0183, // This event counts every cycle that no instructions are committed because the oldest and uncommitted integer load instruction waits for L2 cache access.
		LD_COMP_WAIT = 0x0184, // This event counts every cycle that no instruction was committed because the oldest and uncommitted load/store operation waits for L1D
		LD_COMP_WAIT_EX = 0x0185, // This event counts every cycle that no instructions are committed because the oldest and uncommitted integer load instruction waits for L1D
		LD_COMP_WAIT_PFP_BUSY = 0x0186, // This event counts every cycle that no instructions are committed due to the lack of an available prefetch port.
		LD_COMP_WAIT_PFP_BUSY_EX = 0x0187, // This event counts the LD_COMP_WAIT_PFP_BUSY caused by an integer load operation.
		LD_COMP_WAIT_PFP_BUSY_SWPF = 0x0188, // This event counts the LD_COMP_WAIT_PFP_BUSY caused by a software prefetch instruction.
		EU_COMP_WAIT = 0x0189, // This event counts every cycle that no instructions are committed
		FL_COMP_WAIT = 0x018a, // This event counts every cycle that no instructions are committed
		BR_COMP_WAIT = 0x018b, // This event counts every cycle that no instructions are committed
		ROB_EMPTY = 0x018c, // This event counts every cycle that no instructions are committed because the CSE is empty.
		ROB_EMPTY_STQ_BUSY = 0x018d, // This event counts every cycle that no instructions are committed because the CSE is empty and the all store ports are full.
		WFE_WFI_CYCLE = 0x018e, // This event counts every cycle that the WFE/WFI instruction brings the instruction unit to a halt.
		_0INST_COMMIT = 0x0190, // This event counts every cycle that no instructions are committed
		_1INST_COMMIT = 0x0191, // This event counts every cycle that one instruction is committed.
		_2INST_COMMIT = 0x0192, // This event counts every cycle that two instructions are committed.
		_3INST_COMMIT = 0x0193, // This event counts every cycle that three instructions are committed.
		_4INST_COMMIT = 0x0194, // This event counts every cycle that four instructions are committed.
		UOP_ONLY_COMMIT = 0x0198, // This event counts every cycle that only any micro-operations are committed.
		SINGLE_MOVPRFX_COMMIT = 0x0199, // This event counts every cycle that only the MOVPRFX instruction is committed.
		EAGA_VAL = 0x01a0, // This event counts valid cycles of EAGA pipeline.
		EAGB_VAL = 0x01a1, // This event counts valid cycles of EAGB pipeline.
		EXA_VAL = 0x01a2, // This event counts valid cycles of EXA pipeline.
		EXB_VAL = 0x01a3, // This event counts valid cycles of EXB pipeline.
		FLA_VAL = 0x01a4, // This event counts valid cycles of FLA pipeline.
		FLB_VAL = 0x01a5, // This event counts valid cycles of FLB pipeline.
		PRX_VAL = 0x01a6, // This event counts valid cycles of PRX pipeline.
		FLA_VAL_PRD_CNT = 0x01b4, // This event counts the number of 1 in the predicate bits of request in FLA pipeline
		FLB_VAL_PRD_CNT = 0x01b5, // This event counts the number of 1 in the predicate bits of request in FLB pipeline
		EA_CORE = 0x01e0, // This event counts energy consumption per cycle of core.
		L1D_CACHE_REFILL_DM = 0x0200, // This event counts L1D_CACHE_REFILL caused by demand access.
		L1D_CACHE_REFILL_HWPRF = 0x0202, // This event counts L1D_CACHE_REFILL caused by hardware prefetch.
		L1_MISS_WAIT = 0x0208, // This event counts outstanding L1D cache miss requests per cycle.
		L1I_MISS_WAIT = 0x0209, // This event counts outstanding L1I cache miss requests per cycle.
		L1HWPF_STREAM_PF = 0x0230, // This event counts streaming prefetch requests to L1D cache generated by hardware prefetcher.
		L1HWPF_INJ_ALLOC_PF = 0x0231, // This event counts allocation type prefetch injection requests to L1D cache generated by hardware prefetcher.
		L1HWPF_INJ_NOALLOC_PF = 0x0232, // This event counts non-allocation type prefetch injection requests to L1D cache generated by hardware prefetcher.
		L2HWPF_STREAM_PF = 0x0233, // This event counts streaming prefetch requests to L2 cache generated by hardware prefecher.
		L2HWPF_INJ_ALLOC_PF = 0x0234, // This event counts allocation type prefetch injection requests to L2 cache generated by hardware prefetcher.
		L2HWPF_INJ_NOALLOC_PF = 0x0235, // This event counts non-allocation type prefetch injection requests to L2 cache generated by hardware prefetcher.
		L2HWPF_OTHER = 0x0236, // This event counts prefetch requests to L2 cache generated by the other causes.
		L1_PIPE0_VAL = 0x0240, // This event counts valid cycles of L1D cache pipeline#0.
		L1_PIPE1_VAL = 0x0241, // This event counts valid cycles of L1D cache pipeline#1.
		L1_PIPE0_VAL_IU_TAG_ADRS_SCE = 0x0250, // This event counts requests in L1D cache pipeline#0 that its sce bit of tagged address is 1.
		L1_PIPE0_VAL_IU_TAG_ADRS_PFE = 0x0251, // This event counts requests in L1D cache pipeline#0 that its pfe bit of tagged address is 1.
		L1_PIPE1_VAL_IU_TAG_ADRS_SCE = 0x0252, // This event counts requests in L1D cache pipeline#1 that its sce bit of tagged address is 1.
		L1_PIPE1_VAL_IU_TAG_ADRS_PFE = 0x0253, // This event counts requests in L1D cache pipeline#1 that its pfe bit of tagged address is 1.
		L1_PIPE0_COMP = 0x0260, // This event counts completed requests in L1D cache pipeline#0.
		L1_PIPE1_COMP = 0x0261, // This event counts completed requests in L1D cache pipeline#1.
		L1I_PIPE_COMP = 0x0268, // This event counts completed requests in L1I cache pipeline.
		L1I_PIPE_VAL = 0x0269, // This event counts valid cycles of L1I cache pipeline.
		L1_PIPE_ABORT_STLD_INTLK = 0x0274, // This event counts aborted requests in L1D pipelines that due to store-load interlock.
		L1_PIPE0_VAL_IU_NOT_SEC0 = 0x02a0, // This event counts requests in L1D cache pipeline#0 that its sector cache ID is not 0.
		L1_PIPE1_VAL_IU_NOT_SEC0 = 0x02a1, // This event counts requests in L1D cache pipeline#1 that its sector cache ID is not 0.
		L1_PIPE_COMP_GATHER_2FLOW = 0x02b0, // This event counts the number of times where 2 elements of the gather instructions became 2flows because 2 elements could not be combined.
		L1_PIPE_COMP_GATHER_1FLOW = 0x02b1, // This event counts the number of times where 2 elements of the gather instructions became 1flow because 2 elements could be combined.
		L1_PIPE_COMP_GATHER_0FLOW = 0x02b2, // This event counts the number of times where 2 elements of the gather instructions became 0flow because both predicate values are 0.
		L1_PIPE_COMP_SCATTER_1FLOW = 0x02b3, // This event counts the number of flows of the scatter instructions.
		L1_PIPE0_COMP_PRD_CNT = 0x02b8, // This event counts the number of 1 in the predicate bits of request in L1D cache pipeline#0
		L1_PIPE1_COMP_PRD_CNT = 0x02b9, // This event counts the number of 1 in the predicate bits of request in L1D cache pipeline#1
		L2D_CACHE_REFILL_DM = 0x0300, // This event counts L2D_CACHE_REFILL caused by demand access.
		L2D_CACHE_REFILL_HWPRF = 0x0302, // This event counts L2D_CACHE_REFILL caused by hardware prefetch.
		L2_MISS_WAIT = 0x0308, // This event counts outstanding L2 cache miss requests per cycle. It counts all events caused in measured CMG regardless of measured PE.
		L2_MISS_COUNT = 0x0309, // This event counts the number of times of L2 cache miss. It counts all events caused in measured CMG regardless of measured PE.
		BUS_READ_TOTAL_CMG0 = 0x0310, // This event counts read requests from CMG0 to measured CMG
		BUS_READ_TOTAL_CMG1 = 0x0311, // This event counts read requests from CMG1 to measured CMG
		BUS_READ_TOTAL_CMG2 = 0x0312, // This event counts read requests from CMG2 to measured CMG
		BUS_READ_TOTAL_CMG3 = 0x0313, // This event counts read requests from CMG3 to measured CMG
		BUS_READ_TOTAL_TOFU = 0x0314, // This event counts read requests from tofu controller to measured CMG. It counts all events caused in measured CMG regardless of measured PE.
		BUS_READ_TOTAL_PCI = 0x0315, // This event counts read requests from PCI controller to measured CMG. It counts all events caused in measured CMG regardless of measured PE.
		BUS_READ_TOTAL_MEM = 0x0316, // This event counts read requests from measured CMG local memory to measured CMG. It counts all events caused in measured CMG regardless of measured PE.
		BUS_WRITE_TOTAL_CMG0 = 0x0318, // This event counts write requests from measured CMG to CMG0
		BUS_WRITE_TOTAL_CMG1 = 0x0319, // This event counts write requests from measured CMG to CMG1
		BUS_WRITE_TOTAL_CMG2 = 0x031a, // This event counts write requests from measured CMG to CMG2
		BUS_WRITE_TOTAL_CMG3 = 0x031b, // This event counts write requests from measured CMG to CMG3
		BUS_WRITE_TOTAL_TOFU = 0x031c, // This event counts write requests from measured CMG to tofu controller. It counts all events caused in measured CMG regardless of measured PE.
		BUS_WRITE_TOTAL_PCI = 0x031d, // This event counts write requests from measured CMG to PCI controller. It counts all events caused in measured CMG regardless of measured PE.
		BUS_WRITE_TOTAL_MEM = 0x031e, // This event counts write requests from measured CMG to measured CMG local memory. It counts all events caused in measured CMG regardless of measured PE.
		L2D_SWAP_DM = 0x0325, // This event counts operations where demand access hits an L2 cache refill buffer allocated by software or hardware prefetch.
		L2D_CACHE_MIBMCH_PRF = 0x0326, // This event counts operations where software or hardware prefetch hits an L2 cache refill buffer allocated by demand access.
		L2_PIPE_VAL = 0x0330, // This event counts valid cycles of L2 cache pipeline. It counts all events caused in measured CMG regardless of measured PE.
		L2_PIPE_COMP_ALL = 0x0350, // This event counts completed requests in L2 cache pipeline. It counts all events caused in measured CMG regardless of measured PE.
		L2_PIPE_COMP_PF_L2MIB_MCH = 0x0370, // This event counts operations where software or hardware prefetch hits an L2 cache refill buffer allocated by demand access. It counts all events caused in measured CMG regardless of measured PE.
		L2D_CACHE_SWAP_LOCAL = 0x0396, // This event counts operations where demand access hits an L2 cache refill buffer allocated by software or hardware prefetch. It counts all events caused in measured CMG regardless of measured PE.
		EA_L2 = 0x03e0, // This event counts energy consumption per cycle of L2 cache. It counts all events caused in measured CMG regardless of measured PE.
		EA_MEMORY = 0x03e8, // This event counts energy consumption per cycle of CMG local memory. It counts all events caused in measured CMG regardless of measured PE.
		SIMD_INST_RETIRED = 0x8000, // This event counts architecturally executed SIMD instructions
		SVE_INST_RETIRED = 0x8002, // This event counts architecturally executed Advanced SIMD instructions
		UOP_SPEC = 0x8008, // This event counts all architecturally executed micro-operations.
		SVE_MATH_SPEC = 0x800e, // This event counts architecturally executed math function operations due to the SVE FTSMUL
		FP_SPEC = 0x8010, // This event counts architecturally executed operations due to scalar
		FP_FMA_SPEC = 0x8028, // This event counts architecturally executed floating-point fused multiply-add and multiply-subtract operations.
		FP_RECPE_SPEC = 0x8034, // This event counts architecturally executed floating-point reciprocal estimate operations due to the Advanced SIMD scalar
		FP_CVT_SPEC = 0x8038, // This event counts architecturally executed floating-point convert operations due to the scalar
		ASE_SVE_INT_SPEC = 0x8043, // This event counts architecturally executed integer arithmetic operations due to Advanced SIMD and SVE data-processing instructions listed in Integer instructions section of SVE Reference Manual.
		SVE_PRED_SPEC = 0x8074, // This event counts architecturally executed SIMD data-processing and load/store operations due to SVE instructions with a Governing predicate operand that determines the Active elements.
		SVE_MOVPRFX_SPEC = 0x807c, // This event counts architecturally executed operations due to MOVPRFX instructions
		SVE_MOVPRFX_U_SPEC = 0x807f, // This event counts architecturally executed operations due to MOVPRFX instructions that are not fused with the prefixed instruction.
		ASE_SVE_LD_SPEC = 0x8085, // This event counts architecturally executed operations that read from memory due to SVE and Advanced SIMD load instructions.
		ASE_SVE_ST_SPEC = 0x8086, // This event counts architecturally executed operations that write to memory due to SVE and Advanced SIMD store instructions.
		PRF_SPEC = 0x8087, // This event counts architecturally executed prefetch operations due to scalar PRFM and SVE PRF instructions.
		BASE_LD_REG_SPEC = 0x8089, // This event counts architecturally executed operations that read from memory due to an instruction that loads a general-purpose register.
		BASE_ST_REG_SPEC = 0x808a, // This event counts architecturally executed operations that write to memory due to an instruction that stores a general-purpose register
		SVE_LDR_REG_SPEC = 0x8091, // This event counts architecturally executed operations that read from memory due to an SVE LDR instruction.
		SVE_STR_REG_SPEC = 0x8092, // This event counts architecturally executed operations that write to memory due to an SVE STR instruction.
		SVE_LDR_PREG_SPEC = 0x8095, // This event counts architecturally executed operations that read from memory due to an SVE LDR (predicate) instruction.
		SVE_STR_PREG_SPEC = 0x8096, // This event counts architecturally executed operations that write to memory due to an SVE STR (predicate) instruction.
		SVE_PRF_CONTIG_SPEC = 0x809f, // This event counts architecturally executed operations that prefetch memory due to an SVE predicated single contiguous element prefetch instruction.
		ASE_SVE_LD_MULTI_SPEC = 0x80a5, // This event counts architecturally executed operations that read from memory due to SVE and Advanced SIMD multiple vector contiguous structure load instructions.
		ASE_SVE_ST_MULTI_SPEC = 0x80a6, // This event counts architecturally executed operations that write to memory due to SVE and Advanced SIMD multiple vector contiguous structure store instructions.
		SVE_LD_GATHER_SPEC = 0x80ad, // This event counts architecturally executed operations that read from memory due to SVE noncontiguous gather-load instructions.
		SVE_ST_SCATTER_SPEC = 0x80ae, // This event counts architecturally executed operations that write to memory due to SVE noncontiguous scatter-store instructions.
		SVE_PRF_GATHER_SPEC = 0x80af, // This event counts architecturally executed operations that prefetch memory due to SVE noncontiguous gather-prefetch instructions.
		SVE_LDFF_SPEC = 0x80bc, // This event counts architecturally executed memory read operations due to SVE First-fault and Non-fault load instructions.
		FP_SCALE_OPS_SPEC = 0x80c0, // This event counts architecturally executed SVE arithmetic operations. This event counter is incremented by (128 / CSIZE) and by twice that amount for operations that would also be counted by SVE_FP_FMA_SPEC.
		FP_FIXED_OPS_SPEC = 0x80c1, // This event counts architecturally executed v8SIMD and FP arithmetic operations. The event counter is incremented by the specified number of elements for Advanced SIMD operations or by 1 for scalar operations
		FP_HP_SCALE_OPS_SPEC = 0x80c2, // This event counts architecturally executed SVE half-precision arithmetic operations. This event counter is incremented by 8
		FP_HP_FIXED_OPS_SPEC = 0x80c3, // This event counts architecturally executed v8SIMD and FP half-precision arithmetic operations. This event counter is incremented by the number of 16-bit elements for Advanced SIMD operations
		FP_SP_SCALE_OPS_SPEC = 0x80c4, // This event counts architecturally executed SVE single-precision arithmetic operations. This event counter is incremented by 4
		FP_SP_FIXED_OPS_SPEC = 0x80c5, // This event counts architecturally executed v8SIMD and FP single-precision arithmetic operations. This event counter is incremented by the number of 32-bit elements for Advanced SIMD operations
		FP_DP_SCALE_OPS_SPEC = 0x80c6, // This event counts architecturally executed SVE double-precision arithmetic operations. This event counter is incremented by 2
		FP_DP_FIXED_OPS_SPEC = 0x80c7, // This event counts architecturally executed v8SIMD and FP double-precision arithmetic operations. This event counter is incremented by 2 for Advanced SIMD operations
		
	};
};

namespace a64fx = optkit::arm::a64fx;