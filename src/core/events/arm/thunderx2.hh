#include <cstdint>

namespace optkit_arm{
	enum class thunderx2 : uint64_t {
		SW_INCR = 0x00, // Instruction architecturally executed (condition check pass) software increment}
		L1I_CACHE_REFILL = 0x01, // Level 1 instruction cache refill}
		L1I_TLB_REFILL = 0x02, // Level 1 instruction TLB refill}
		L1D_CACHE_REFILL = 0x03, // Level 1 data cache refill}
		L1D_CACHE = 0x04, // Level 1 data cache access}
		L1D_TLB_REFILL = 0x05, // Level 1 data TLB refill}
		LD_RETIRED = 0x06, // Instruction architecturally executed (condition check pass) - Load}
		ST_RETIRED = 0x07, // Instruction architecturally executed (condition check pass) - Store}
		INST_RETIRED = 0x08, // Instruction architecturally executed}
		EXC_TAKEN = 0x09, // Exception taken}
		EXC_RETURN = 0x0A, // Instruction architecturally executed (condition check pass) - Exception return}
		CID_WRITE_RETIRED = 0x0B, // Instruction architecturally executed (condition check pass) - Write to CONTEXTIDR}
		BR_IMMED_RETIRED = 0x0D, // Instruction architecturally executed
		BR_RETURN_RETIRED = 0x0E, // Instruction architecturally executed (condition check pass) - procedure return}
		UNALIGNED_LDST_RETIRED = 0x0F, // Instruction architecturally executed (condition check pass)
		BR_MIS_PRED = 0x10, // Mispredicted or not predicted branch speculatively executed}
		CPU_CYCLES = 0x11, // Cycles}
		BR_PRED = 0x12, // Predictable branch speculatively executed}
		MEM_ACCESS = 0x13, // Data memory access}
		L1I_CACHE = 0x14, // Level 1 instruction cache access}
		L1D_CACHE_WB = 0x15, // Level 1 data cache write-back}
		L2D_CACHE = 0x16, // Level 2 data cache access}
		L2D_CACHE_REFILL = 0x17, // Level 2 data cache refill}
		L2D_CACHE_WB = 0x18, // Level 2 data cache write-back}
		BUS_ACCESS = 0x19, // Bus access}
		INST_SPEC = 0x1B, // Instruction speculatively executed}
		TTBR_WRITE_RETIRED = 0x1C, // Instruction architecturally executed (condition check pass)  Write to translation table base}
		CHAIN = 0x1E, // For odd-numbered counters
		L1D_CACHE_ALLOCATE = 0x1F, // Level 1 data cache allocation without refill}
		L2D_CACHE_ALLOCATE = 0x20, // Level 2 data/unified cache allocation without refill}
		BR_RETIRED = 0x21, // Counts all branches on the architecturally executed path that would incur cost if mispredicted}
		BR_MIS_PRED_RETIRED = 0x22, // Instructions executed
		STALL_FRONTEND = 0x23, // Cycle on which no operation issued because there were no operations to issue}
		STALL_BACKEND = 0x24, // Cycle on which no operation issued due to back-end resources being unavailable}
		L1D_TLB = 0x25, // Level 1 data TLB access}
		L1I_TLB = 0x26, // Instruction TLB access}
		L2D_TLB_REFILL = 0x2D, // Attributable memory-read or attributable memory-write operation that causes a TLB refill}
		L2I_TLB_REFILL = 0x2E, // Attributable instruction memory access that causes a TLB refill}
		L2D_TLB = 0x2F, // Attributable memory read operation or attributable memory write operation that causes a TLB access}
		L2I_TLB = 0x30, // Attributable memory read operation or attributable memory write operation that causes a TLB access}
		L1D_CACHE_RD = 0x40, // Level 1 data cache access
		L1D_CACHE_WR = 0x41, // Level 1 data cache access
		L1D_CACHE_REFILL_RD = 0x42, // Level 1 data cache refill
		L1D_CACHE_REFILL_WR = 0x43, // Level 1 data cache refill
		L1D_CACHE_REFILL_INNER = 0x44, // Level 1 data cache refill
		L1D_CACHE_REFILL_OUTER = 0x45, // Level 1 data cache refill
		L1D_CACHE_WB_VICTIM = 0x46, // Level 1 data cache write-back
		L1D_CACHE_WB_CLEAN = 0x47, // Level 1 data cache write-back
		L1D_CACHE_INVAL = 0x48, // Level 1 data cache invalidate}
		L1D_TLB_REFILL_RD = 0x4C, // Level 1 data TLB read refill}
		L1D_TLB_REFILL_WR = 0x4D, // Level 1 data TLB write refill}
		L1D_TLB_RD = 0x4E, // Level 1 data TLB access
		L1D_TLB_WR = 0x4F, // Level 1 data TLB access
		L2D_CACHE_RD = 0x50, // Level 2 data cache access
		L2D_CACHE_WR = 0x51, // Level 2 data cache access
		L2D_CACHE_REFILL_RD = 0x52, // Level 2 data cache refill
		L2D_CACHE_REFILL_WR = 0x53, // Level 2 data cache refill
		L2D_CACHE_WB_VICTIM = 0x56, // Level 2 data cache write-back
		L2D_CACHE_WB_CLEAN = 0x57, // Level 2 data cache write-back
		L2D_CACHE_INVAL = 0x58, // Level 2 data cache invalidate}
		L2D_TLB_REFILL_RD = 0x5C, // Level 2 data/unified TLB refill
		L2D_TLB_REFILL_WR = 0x5D, // Level 2 data/unified TLB refill
		L2D_TLB_RD = 0x5E, // Level 2 data/unified TLB access
		L2D_TLB_WR = 0x5F, // Level 2 data/unified TLB access
		BUS_ACCESS_RD = 0x60, // Bus access
		BUS_ACCESS_WR = 0x61, // Bus access
		BUS_ACCESS_SHARED = 0x62, // Bus access
		BUS_ACCESS_NOT_SHARED = 0x63, // Bus not normal access}
		BUS_ACCESS_NORMAL = 0x64, // Bus access
		BUS_ACCESS_PERIPH = 0x65, // Bus access
		MEM_ACCESS_RD = 0x66, // Data memory access
		MEM_ACCESS_WR = 0x67, // Data memory access
		UNALIGNED_LD_SPEC = 0x68, // Unaligned access
		UNALIGNED_ST_SPEC = 0x69, // Unaligned access
		UNALIGNED_LDST_SPEC = 0x6A, // Unaligned access}
		LDREX_SPEC = 0x6C, // Exclusive operation speculatively executed - LDREX or LDX}
		STREX_PASS_SPEC = 0x6D, // Exclusive operation speculative executed - STREX or STX pass}
		STREX_FAIL_SPEC = 0x6E, // Exclusive operation speculative executed - STREX or STX fail}
		STREX_SPEC = 0x6F, // Exclusive operation speculatively executed - STREX or STX}
		LD_SPEC = 0x70, // Operation speculatively executed
		ST_SPEC = 0x71, // Operation speculatively executed
		LDST_SPEC = 0x72, // Operation speculatively executed
		DP_SPEC = 0x73, // Operation speculatively executed
		ASE_SPEC = 0x74, // Operation speculatively executed
		VFP_SPEC = 0x75, // Operation speculatively executed
		CRYPTO_SPEC = 0x77, // Operation speculatively executed
		BR_IMMED_SPEC = 0x78, // Branch speculatively executed
		BR_RETURN_SPEC = 0x79, // Branch speculatively executed
		BR_INDIRECT_SPEC = 0x7A, // Branch speculatively executed
		ISB_SPEC = 0x7C, // Barrier speculatively executed
		DSB_SPEC = 0x7D, // barrier speculatively executed
		DMB_SPEC = 0x7E, // Barrier speculatively executed
		EXC_UNDEF = 0x81, // Exception taken
		EXC_SVC = 0x82, // Exception taken
		EXC_PABORT = 0x83, // Exception taken
		EXC_DABORT = 0x84, // Exception taken
		EXC_IRQ = 0x86, // Exception taken
		EXC_FIQ = 0x87, // Exception taken
		EXC_SMC = 0x88, // Exception taken
		EXC_HVC = 0x8A, // Exception taken
		EXC_TRAP_PABORT = 0x8B, // Exception taken
		EXC_TRAP_DABORT = 0x8C, // Exception taken
		EXC_TRAP_OTHER = 0x8D, // Exception taken
		EXC_TRAP_IRQ = 0x8E, // Exception taken
		EXC_TRAP_FIQ = 0x8F, // Exception taken
		RC_LD_SPEC = 0x90, // Release consistency instruction speculatively executed (load-acquire)}
		RC_ST_SPEC = 0x91, // Release consistency instruction speculatively executed (store-release)}
		L1D_LHS_VANOTP = 0xC1, // A Load hit store retry}
		L1D_LHS_OVRLAP = 0xC2, // A Load hit store retry
		L1D_LHS_VANOSD = 0xC3, // A Load hit store retry
		L1D_LHS_FWD = 0xC4, // A Load hit store forwarding. Load completes}
		L1D_BNKCFL = 0xC6, // Bank conflict load retry}
		L1D_LSMQ_FULL = 0xC7, // LSMQ retry}
		L1D_LSMQ_HIT = 0xC8, // LSMQ hit retry}
		L1D_EXPB_MISS = 0xC9, // An external probe missed the L1}
		L1D_L2EV_MISS = 0xCA, // An L2 evict operation missed the L1}
		L1D_EXPB_HITM = 0xCB, // An external probe hit a modified line in the L1}
		L1D_L2EV_HITM = 0xCC, // An L2 evict operation hit a modified line in the L1}
		L1D_EXPB_HIT = 0xCD, // An external probe hit in the L1}
		L1D_L2EV_HIT = 0xCE, // An L2 evict operation hit in the L1}
		L1D_EXPB_RETRY = 0xCF, // An external probe hit was retried}
		L1D_L2EV_RETRY = 0xD0, // An L2 evict operation was retried}
		L1D_ST_RMW = 0xD1, // A read modify write store was drained and updated the L1}
		L1D_LSMQ00_LDREQ = 0xD2, // A load has allocated LSMQ entry 0}
		L1D_LSMQ00_LDVLD = 0xD3, // LSMQ entry 0 was initiated by a load}
		L1D_LSMQ15_STREQ = 0xD4, // A store was allocated LSMQ entry 15}
		L1D_LSMQ15_STVLD = 0xD5, // LSMQ entry 15 was initiated by a store}
		L1D_PB_FLUSH = 0xD6, // LRQ ordering flush}
		BR_COND_MIS_PRED_RETIRED = 0xE0, // Conditional branch instruction executed
		BR_IND_MIS_PRED_RETIRED = 0xE1, // Indirect branch instruction executed
		BR_RETURN_MIS_PRED_RETIRED = 0xE2, // Return branch instruction executed
		OP_RETIRED = 0xE8, // Uops executed}
		LD_OP_RETIRED = 0xE9, // Load uops executed}
		ST_OP_RETIRED = 0xEA, // Store uops executed}
		FUSED_OP_RETIRED = 0xEB, // Fused uops executed}
		IRQ_MASK = 0xF8, // Cumulative duration of a PSTATE.I interrupt mask set to 1}
		FIQ_MASK = 0xF9, // Cumulative duration of a PSTATE.F interrupt mask set to 1}
		SERROR_MASK = 0xFA, // Cumulative duration of PSTATE.A interrupt mask set to 1}
		WFIWFE_SLEEP = 0x108, // Number of cycles in which CPU is in low power mode due to WFI/WFE instruction}
		L2TLB_4K_PAGE_MISS = 0x127, // L2 TLB lookup miss using 4K page size}
		L2TLB_64K_PAGE_MISS = 0x128, // L2 TLB lookup miss using 64K page size}
		L2TLB_2M_PAGE_MISS = 0x129, // L2 TLB lookup miss using 2M page size}
		L2TLB_512M_PAGE_MISS = 0x12A, // L2 TLB lookup miss using 512M page size}
		ISB_EMPTY = 0x150, // Number of cycles during which micro-op skid-buffer is empty}
		ISB_FULL = 0x151, // Number of cycles during which micro-op skid-buffer is back-pressuring decode}
		STALL_NOTSELECTED = 0x152, // Number of cycles during which thread was available for dispatch but not selected}
		ROB_RECYCLE = 0x153, // Number of cycles in which one or more valid micro-ops did not dispatch due to ROB full}
		ISSQ_RECYCLE = 0x154, // Number of cycles in which one or more valid micro-ops did not dispatch due to ISSQ full}
		GPR_RECYCLE = 0x155, // Number of cycles in which one or more valid micro-ops did not dispatch due to GPR full}
		FPR_RECYCLE = 0x156, // Number of cycles in which one or more valid micro-ops did not dispatch due to FPR full}
		LRQ_RECYCLE = 0x158, // Number of cycles in which one or more valid micro-ops did not dispatch due to LRQ full}
		SRQ_RECYCLE = 0x159, // Number of cycles in which one or more valid micro-ops did not dispatch due to SRQ full}
		BSR_RECYCLE = 0x15B, // Number of cycles in which one or more valid micro-ops did not dispatch due to BSR full}
		UOPSFUSED = 0x164, // Number of fused micro-ops dispatched}
		L2D_TLBI_INT = 0x20B, // Internal mmu tlbi cacheops}
		L2D_TLBI_EXT = 0x20C, // External mmu tlbi cacheops}
		L2D_HWPF_DMD_HIT = 0x218, // Scu ld/st requests that hit cache or msg for lines brought in by the hardware prefetcher}
		L2D_HWPF_REQ_VAL = 0x219, // Scu hwpf requests into the pipeline}
		L2D_HWPF_REQ_LD = 0x21A, // Scu hwpf ld requests into the pipeline}
		L2D_HWPF_REQ_MISS = 0x21B, // Scu hwpf ld requests that miss}
		L2D_HWPF_NEXT_LINE = 0x21C, // Scu hwpf next line requests generated}
		};};