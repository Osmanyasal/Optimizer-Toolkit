#include <cstdint>

namespace optkit_ultra4plus{
	enum class pe : uint64_t {
		Cycle_cnt = 0x0, // Accumulated cycles
		Instr_cnt = 0x1, // Number of instructions completed
		Dispatch0_IC_miss = 0x2, // I-buffer is empty from I-Cache miss
		IU_stat_jmp_correct_pred = 0x3, // Retired non-annulled register indirect jumps predicted correctly
		Dispatch0_2nd_br = 0x4, // Stall cycles due to having two branch instructions line-up in one 4-instruction group causing the second branch in the group to be re-fetched
		Rstall_storeQ = 0x5, // R-stage stall for a store instruction which is the next instruction to be executed
		Rstall_IU_use = 0x6, // R-stage stall for an event that the next instruction to be executed depends on the result of a preceding integer instruction in the pipeline that is not yet available
		IU_stat_ret_correct_pred = 0x7, // Retired non-annulled returns predicted correctly
		IC_ref = 0x8, // I-cache references
		DC_rd = 0x9, // D-cache read references (including accesses that subsequently trap)
		Rstall_FP_use = 0xa, // R-stage stall for an event that the next instruction to be executed depends on the result of a preceding floating-point instruction in the pipeline that is not yet available
		SW_pf_instr = 0xb, // Retired SW prefetch instructions
		L2_ref = 0xc, // L2-cache references
		L2_write_hit_RTO = 0xd, // L2-cache exclusive requests that hit L2-cache in S
		L2_snoop_inv_sh = 0xe, // L2 cache lines that were written back to the L3 cache due to requests from both cores
		L2_rd_miss = 0xf, // L2-cache miss events (including atomics) from D-cache events
		PC_rd = 0x10, // P-cache cacheable loads
		SI_snoop_sh = 0x11, // Counts snoops from remote processor(s) including RTS
		SI_ciq_flow_sh = 0x12, // Counts system clock cycles when the flow control (PauseOut) signal is asserted
		Re_DC_miss = 0x13, // Stall due to loads that miss D-cache and get recirculated
		SW_count_NOP0 = 0x14, // Retired
		IU_Stat_Br_miss_taken = 0x15, // Retired branches that were predicted to be taken
		IU_Stat_Br_Count_taken = 0x16, // Retired taken branches
		HW_pf_exec = 0x17, // Hardware prefetches enqueued in the prefetch queue
		FA_pipe_completion = 0x18, // Instructions that complete execution on the FPG ALU pipelines
		SSM_L3_wb_remote = 0x19, // L3 cache line victimizations from this core which generate R_WB transactions to non-LPA (remote physical address) regions
		SSM_L3_miss_local = 0x1a, // L3 cache misses to LPA (local physical address) from this core which generate an RTS
		SSM_L3_miss_mtag_remote = 0x1b, // L3 cache misses to LPA (local physical address) from this core which generate retry (R_*) transactions including R_RTS
		SW_pf_str_trapped = 0x1c, // Strong software prefetch instructions trapping due to TLB miss
		SW_pf_PC_installed = 0x1d, // Software prefetch instructions that installed lines in the P-cache
		IPB_to_IC_fill = 0x1e, // I-cache fills from the instruction prefetch buffer
		L2_write_miss = 0x1f, // L2-cache misses from this core by cacheable store requests
		MC_reads_0_sh = 0x20, // Read requests completed to memory bank 0
		MC_reads_1_sh = 0x21, // Read requests completed to memory bank 1
		MC_reads_2_sh = 0x22, // Read requests completed to memory bank 2
		MC_reads_3_sh = 0x23, // Read requests completed to memory bank 3
		MC_stalls_0_sh = 0x24, // Clock cycles that requests were stalled in the MCU queues because bank 0 was busy with a previous request
		MC_stalls_2_sh = 0x25, // Clock cycles that requests were stalled in the MCU queues because bank 2 was busy with a previous request
		L2_hit_other_half = 0x26, // L2 cache hits from this core to the ways filled by the other core when the cache is in the pseudo-split mode
		L3_rd_miss = 0x28, // L3 cache misses sent out to SIU from this code by cacheable I-cache
		Re_L2_miss = 0x29, // Stall cycles due to recirculation of cacheable loads that miss both D-cache and L2 cache
		IC_miss_cancelled = 0x2a, // I-cache miss requests cancelled due to new fetch stream
		DC_wr_miss = 0x2b, // D-cache store accesses that miss D-cache
		L3_hit_I_state_sh = 0x2c, // Tag hits in L3 cache when the line is in I state
		SI_RTS_src_data = 0x2d, // Local RTS transactions due to I-cache
		L2_IC_miss = 0x2e, // L2 cache misses from this code by cacheable I-cache requests
		SSM_new_transaction_sh = 0x2f, // New SSM transactions (RTSU
		L2_SW_pf_miss = 0x30, // L2 cache misses by software prefetch requests from this core
		L2_wb = 0x31, // L2 cache lines that were written back to the L3 cache because of requests from this core
		L2_wb_sh = 0x32, // L2 cache lines that were written back to the L3 cache because of requests from both cores
		L2_snoop_cb_sh = 0x33, // L2 cache lines that were copied back due to other processors
		Dispatch0_other = 0x2, // Stall cycles due to the event that no instructions are dispatched because the I-queue is empty due to various other events
		DC_wr = 0x3, // D-cache write references by cacheable stores (excluding block stores)
		Re_DC_missovhd = 0x4, // Stall cycles due to D-cache load miss
		Re_FPU_bypass = 0x5, // Stall due to recirculation when an FPU bypass condition that does not have a direct bypass path occurs
		L3_write_hit_RTO = 0x6, // L3 cache hits in O
		L2L3_snoop_inv_sh = 0x7, // L2 and L3 cache lines that were invalidated due to other processors doing RTO
		IC_L2_req = 0x8, // I-cache requests sent to L2 cache
		DC_rd_miss = 0x9, // Cacheable loads (excluding atomics and block loads) that miss D-cache as well as P-cache (for FP loads)
		L2_hit_I_state_sh = 0xa, // Tag hits in L2 cache when the line is in I state
		L3_write_miss_RTO = 0xb, // 2
		L2_miss = 0xc, // L2 cache misses from this core by cacheable I-cache
		SI_owned_sh = 0xd, // Number of times owned_in is asserted on bus requests from the local processor
		SI_RTO_src_data = 0xe, // Number of local RTO transactions due to W-cache or P-cache requests from this core where data is from the cache of another processor on the system
		SW_pf_duplicate = 0xf, // Number of software prefetch instructions that were dropped because the prefetch request matched an outstanding requests in the prefetch queue or the request hit the P-cache
		IU_stat_jmp_mispred = 0x10, // Number of retired non-annulled register indirect jumps mispredicted
		ITLB_miss = 0x11, // I-TLB misses
		DTLB_miss = 0x12, // D-TLB misses
		WC_miss = 0x13, // W-cache misses
		IC_fill = 0x14, // Number of I-cache fills excluding fills from the instruction prefetch buffer.  This is the best approximation of the number of I-cache misses for instructions that were actually executed
		IU_stat_ret_mispred = 0x15, // Number of retired non-annulled returns mispredicted
		Re_L3_miss = 0x16, // Stall cycles due to recirculation of cacheable loads that miss D-cache
		Re_PFQ_full = 0x17, // Stall cycles due to recirculation of prefetch instructions because the prefetch queue (PFQ) was full
		PC_soft_hit = 0x18, // Number of cacheable FP loads that hit a P-cache line that was prefetched by a software prefetch instruction
		PC_inv = 0x19, // Number of P-cache lines that were invalidated due to external snoops
		PC_hard_hit = 0x1a, // Number of FP loads that hit a P-cache line that was fetched by a FP load or a hardware prefetch
		IC_pf = 0x1b, // Number of I-cache prefetch requests sent to L2 cache
		SW_count_NOP1 = 0x1c, // Retired
		IU_stat_br_miss_untaken = 0x1d, // Number of retired non-annulled conditional branches that were predicted to be not taken
		IU_stat_br_count_taken = 0x1e, // Number of retired non-annulled conditional branches that were taken
		PC_miss = 0x1f, // Number of cacheable FP loads that miss P-cache
		MC_writes_0_sh = 0x20, // Number of write requests complete to memory bank 0
		MC_writes_1_sh = 0x21, // Number of write requests complete to memory bank 1
		MC_writes_2_sh = 0x22, // Number of write requests complete to memory bank 2
		MC_writes_3_sh = 0x23, // Number of write requests complete to memory bank 3
		MC_stalls_1_sh = 0x24, // Number of processor cycles that requests were stalled in the MCU queues because bank 0 was busy with a previous requests
		MC_stalls_3_sh = 0x25, // Number of processor cycles that requests were stalled in the MCU queues because bank 3 was busy with a previous requests
		Re_RAW_miss = 0x26, // Stall cycles due to recirculation when there is a load instruction in the E-stage of the pipeline which has a non-bypassable read-after-write (RAW) hazard with an earlier store instruction
		FM_pipe_completion = 0x27, // Number of retired instructions that complete execution on the FLoat-Point/Graphics Multiply pipeline
		SSM_L3_miss_remote = 0x29, // Number of L3 cache misses from this core which generate retry (R_*) transactions to non-LPA (non-local physical address) address space
		SW_pf_exec = 0x2a, // Number of retired
		SW_pf_str_exec = 0x2b, // Number of retired
		SW_pf_dropped = 0x2c, // Number of software prefetch instructions dropped due to TLB miss or due to the prefetch queue being full
		SW_pf_L2_installed = 0x2d, // Number of software prefetch instructions that installed lines in the L2 cache
		L2_HW_pf_miss = 0x2f, // Number of L2 cache misses by hardware prefetch requests from this core
		L3_miss = 0x31, // Number of L3 cache misses sent out to SIU from this core by cacheable I-cache
		L3_IC_miss = 0x32, // Number of L3 cache misses by cacheable I-cache requests from this core
		L3_SW_pf_miss = 0x33, // Number of L3 cache misses by software prefetch requests from this core
		L3_hit_other_half = 0x34, // Number of L3 cache hits from this core to the ways filled by the other core when the cache is in pseudo-split mode
		L3_wb = 0x35, // Number of L3 cache lines that were written back because of requests from this core
		L3_wb_sh = 0x36, // Number of L3 cache lines that were written back because of requests from both cores
		L2L3_snoop_cb_sh = 0x37, // Total number of L2 and L3 cache lines that were copied back due to other processors
		};};